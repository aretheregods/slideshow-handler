<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Native PPTX Parser - Step 4</title>
    <script type="importmap">
        {
            "imports": {
                "utils": "./src/utils/index.js"
            }
        }
    </script>
    <style>
        /* General Body Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #f9fafb;
            color: #1f2937;
            margin: 0;
            padding: 0;
            line-height: 1.5;
        }

        /* Container and Layout */
        .container {
            width: 100%;
            max-width: 56rem;
            /* 896px */
            margin-left: auto;
            margin-right: auto;
            padding: 2rem 1rem;
        }

        /* Header and Typography */
        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2.25rem;
            /* 36px */
            font-weight: 700;
            color: #111827;
        }

        header p {
            margin-top: 0.5rem;
            font-size: 1.125rem;
            /* 18px */
            color: #4b5563;
        }

        /* Card-like Sections */
        .card {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .card h2 {
            font-size: 1.5rem;
            /* 24px */
            font-weight: 600;
            margin-bottom: 1rem;
        }

        /* File Upload Area */
        .file-upload-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 12rem;
            /* 192px */
            border: 2px dashed #d1d5db;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #f9fafb;
            transition: background-color 0.2s ease-in-out;
        }

        .file-upload-label:hover {
            background-color: #f3f4f6;
        }

        #pptx-file {
            display: none;
        }

        #file-info {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.875rem;
            /* 14px */
            color: #6b7280;
        }

        /* --- Slide Viewer & Debug Styling --- */
        .slide-viewer {
            width: 100%;
            height: 100%;
            border: 1px solid #e5e7eb;
            background-color: #fff;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin: 2rem auto;
            position: relative;
        }

        .slide-viewer svg {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
            /* For visualization */
        }

        #debug-output {
            margin-top: 1.5rem;
            background-color: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: "SF Mono", "Fira Code", "Fira Mono", "Roboto Mono", monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #debug-output h3 {
            margin-top: 0;
            color: #9ca3af;
            font-weight: 500;
        }

        /* Loading Spinner */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>Native PPTX Parser</h1>
            <p><strong>Step 4:</strong> Integrating Slide Layouts for correct positioning.</p>
        </header>

        <div>
            <!-- File Upload Section -->
            <div class="card">
                <h2>1. Upload Presentation</h2>
                <div>
                    <label for="pptx-file" class="file-upload-label">
                        <!-- SVG icon for upload -->
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                            </path>
                        </svg>
                        <p><span>Click to upload</span> or drag and drop</p>
                        <p>PPTX file</p>
                        <input id="pptx-file" type="file" accept=".pptx" />
                    </label>
                </div>
                <div id="file-info"></div>
            </div>

            <!-- Slide Render Section -->
            <div id="output-container" style="display: none;">
                <div id="loading-indicator" style="text-align: center; padding: 2rem;">
                    <!-- SVG spinner -->
                    <svg aria-hidden="true"
                        style="display: inline; width: 2rem; height: 2rem; margin-right: 0.5rem; color: #e5e7eb; animation: spin 1s linear infinite;"
                        viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
                            fill="currentColor" />
                        <path
                            d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
                            fill="#4f46e5" />
                    </svg>
                    <p>Rendering slides...</p>
                </div>
                <div id="slide-viewer-container"></div>
                <div id="debug-output" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Main application script -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.2.0/dist/chart.umd.js"></script>
    <script type="module">
        import {
            BlobReader,
            BlobWriter,
            TextReader,
            TextWriter,
            ZipReader,
            ZipWriter,
        } from "https://deno.land/x/zipjs/index.js";
        import { SvgRenderer, integerToRoman, Matrix, ShapeBuilder } from 'utils';

        const EMU_PER_PIXEL = 12700; // Standard conversion for 96 DPI
        const PT_TO_PX = .975; // Adjusted conversion for web rendering (90/72)
        const LINE_HEIGHT = 24; // A default line height in pixels for SVG text
        const INDENTATION_AMOUNT = 30; // Pixels per indentation level
        const BULLET_OFFSET = 20; // Space between bullet and text

        const fileInput = document.getElementById( 'pptx-file' );
        const fileInfo = document.getElementById( 'file-info' );
        const outputContainer = document.getElementById( 'output-container' );
        let activeCharts = [];
        const slideViewerContainer = document.getElementById( 'slide-viewer-container' );
        const loadingIndicator = document.getElementById( 'loading-indicator' );
        const debugOutput = document.getElementById( 'debug-output' );

        function resolvePath(baseDir, target) {
            // Normalize backslashes to forward slashes for cross-platform compatibility.
            const normalizedTarget = target.replace(/\\/g, '/');

            // If target is an absolute path (starts with '/'), it's relative to the zip root.
            if (normalizedTarget.startsWith('/')) {
                // Just remove the leading slash and return.
                return normalizedTarget.substring(1);
            }
            // Otherwise, resolve it relative to the baseDir.
            const path = baseDir + '/' + normalizedTarget;
            const parts = path.split('/');
            const resolved = [];
            for (const part of parts) {
                if (part === '..') {
                    resolved.pop();
                } else if (part !== '.' && part !== '') {
                    resolved.push(part);
                }
            }
            return resolved.join('/');
        }
        function parseXmlString(xmlString, identifier) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            const errorNode = xmlDoc.querySelector("parsererror");
            if (errorNode) {
                console.error(`XML Parsing Error in ${identifier}:`, errorNode.innerHTML);
                console.log(`Problematic XML for ${identifier}:`, xmlString);
            }
            return xmlDoc;
        }

        async function getNormalizedXmlString(entriesMap, path) {
            const entry = entriesMap.get(path);
            if (!entry) return null;

            const writer = new TextWriter();
            let xmlString = await entry.getData(writer);

            // Strip BOM if present, as it can interfere with XML parsing on some platforms.
            if (xmlString.charCodeAt(0) === 0xFEFF) {
                xmlString = xmlString.substring(1);
            }

            // Normalize line endings to prevent cross-platform parsing issues.
            return xmlString.replace(/\\r\\n/g, '\n').replace(/\\r/g, '\n');
        }

        fileInput.addEventListener( 'change', async ( event ) => {
            const file = event.target.files[ 0 ];
            if ( !file ) return;

            fileInfo.textContent = `File selected: ${ file.name }`;
            outputContainer.style.display = 'block';
            slideViewerContainer.innerHTML = '';
            debugOutput.style.display = 'none';
            loadingIndicator.style.display = 'block';
            debugOutput.innerHTML = '';

            const zipReader = new ZipReader(new BlobReader(file));
            try {
                const entries = await zipReader.getEntries();
                const entriesMap = new Map(entries.map(entry => [entry.filename, entry]));

                const presRels = await getRelationships( entriesMap, "ppt/_rels/presentation.xml.rels" );
                const sortedPresRels = Object.values(presRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));

                let theme = null;
                const themeRel = sortedPresRels.find(rel => rel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme');
                if (themeRel) {
                    const themePath = resolvePath('ppt', themeRel.target);
                    const themeXml = await getNormalizedXmlString(entriesMap, themePath);
                    if (themeXml) theme = parseTheme(themeXml);
                }

                let tableStyles = {};
                let defaultTableStyleId = null;
                const tableStylesRel = sortedPresRels.find(rel => rel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles');
                if (tableStylesRel) {
                    const tableStylesPath = resolvePath('ppt', tableStylesRel.target);
                    const tableStylesXml = await getNormalizedXmlString(entriesMap, tableStylesPath);
                    if (tableStylesXml) {
                        const tableStylesResult = parseTableStyles(tableStylesXml);
                        tableStyles = tableStylesResult.styles;
                        defaultTableStyleId = tableStylesResult.defaultStyleId;
                    }
                }

                const presentationXml = await getNormalizedXmlString(entriesMap, "ppt/presentation.xml");
                const slideIds = getSlideOrder( presentationXml );

                const slideSize = getSlideSize( presentationXml );

                if ( slideIds.length === 0 ) {
                    fileInfo.textContent = "No slides found in the presentation.";
                    return;
                }

                let allSlidesDebugText = '<h3>Raw Parsed Content:</h3>';
                let totalElementsFound = 0;

                for ( let i = 0; i < slideIds.length; i++ ) {
                    const slideNum = i + 1;
                    const slideId = slideIds[ i ];
                    const slideRel = presRels[ slideId ];
                    if ( !slideRel ) continue;

                    const slidePath = resolvePath( 'ppt', slideRel.target );
                    const slideRelsPath = `ppt/slides/_rels/${ slidePath.split( '/' ).pop() }.rels`;
                    const slideRels = await getRelationships( entriesMap, slideRelsPath );
                    const sortedSlideRels = Object.values(slideRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));

                    const imageMap = {};
                    await populateImageMap(imageMap, slideRels, 'ppt/slides', entriesMap);


                    const slideContext = {
                        theme: theme,
                        colorMap: {},
                        tableStyles: tableStyles,
                        defaultTableStyleId: defaultTableStyleId,
                    };

                    const layoutRel = sortedSlideRels.find( r => r.type.endsWith( '/slideLayout' ) );

                    let masterPlaceholders = {};
                    let layoutPlaceholders = {};
                    let defaultTextStyles = {};
                    let masterXml, layoutXml;

                    let masterStaticShapes = [], layoutStaticShapes = [];
                    if ( layoutRel ) {
                        const layoutPath = resolvePath('ppt/slides', layoutRel.target);
                        const layoutRelsPath = `ppt/slideLayouts/_rels/${ layoutPath.split( '/' ).pop() }.rels`;
                        const layoutRels = await getRelationships( entriesMap, layoutRelsPath );
                        await populateImageMap(imageMap, layoutRels, 'ppt/slideLayouts', entriesMap);
                        const sortedLayoutRels = Object.values(layoutRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));
                        const masterRel = sortedLayoutRels.find( r => r.type.endsWith( '/slideMaster' ) );

                        let masterData;
                        if ( masterRel ) {
                            const masterPath = resolvePath('ppt/slideLayouts', masterRel.target);
                            const masterRelsPath = `ppt/slideMasters/_rels/${masterPath.split('/').pop()}.rels`;
                            const masterRels = await getRelationships( entriesMap, masterRelsPath );
                            await populateImageMap(imageMap, masterRels, 'ppt/slideMasters', entriesMap);

                            masterXml = await getNormalizedXmlString(entriesMap, masterPath);
                            if (masterXml) {
                                masterData = parseMasterOrLayout( masterXml, theme, null, false );
                            }
                            masterPlaceholders = masterData.placeholders;
                            masterStaticShapes = masterData.staticShapes;
                            defaultTextStyles = masterData.defaultTextStyles;
                            slideContext.colorMap = masterData.colorMap;
                        }

                        let layoutData;
                        layoutXml = await getNormalizedXmlString(entriesMap, layoutPath);
                        if (layoutXml) {
                            layoutData = parseMasterOrLayout( layoutXml, theme, masterData ? masterData.colorMap : null, true );
                        }
                        layoutPlaceholders = layoutData.placeholders;
                        layoutStaticShapes = layoutData.staticShapes;
                        if (layoutData.colorMapOverride) {
                            slideContext.colorMap = { ...slideContext.colorMap, ...layoutData.colorMapOverride };
                        }
                    }

                    const slideXml = await getNormalizedXmlString(entriesMap, slidePath);

                    const slideXmlDoc = parseXmlString(slideXml, `slide ${slideId}`);
                    const layoutXmlDoc = layoutXml ? parseXmlString(layoutXml, `layout for slide ${slideId}`) : null;
                    const masterXmlDoc = masterXml ? parseXmlString(masterXml, `master for slide ${slideId}`) : null;

                    const sldNode = slideXmlDoc.getElementsByTagNameNS("http://schemas.openxmlformats.org/presentationml/2006/main", 'sld')[0];
                    const showMasterShapes = !sldNode || sldNode.getAttribute('showMasterSp') !== '0';

                    const slideBg = parseBackground(slideXmlDoc, slideContext);
                    const layoutBg = layoutXmlDoc ? parseBackground(layoutXmlDoc, slideContext) : null;
                    const masterBg = masterXmlDoc ? parseBackground(masterXmlDoc, slideContext) : null;
                    const finalBg = slideBg || layoutBg || masterBg;

                    const slideContainer = document.createElement( 'div' );
                    slideContainer.className = 'slide-viewer';
                    slideContainer.id = `slide-${ i + 1 }`;
                    slideContainer.style.aspectRatio = `${slideSize.width} / ${slideSize.height}`;
                    slideContainer.style.width = `${slideSize.width}px`;
                    slideContainer.style.height = `${slideSize.height}px`;
                    slideViewerContainer.appendChild( slideContainer );

                    // The renderSlide function now handles its own scaling.
                    await renderSlide( slideXml, slideContainer, masterPlaceholders, layoutPlaceholders, slideNum, slideSize, defaultTextStyles, imageMap, slideContext, finalBg, showMasterShapes, masterStaticShapes, layoutStaticShapes, slideRels, entriesMap );
                }

            } catch ( error ) {
                console.error( 'Error parsing the presentation:', error );
                fileInfo.textContent = `Error: Could not parse presentation. ${ error.message }`;
            } finally {
                await zipReader.close();
                loadingIndicator.style.display = 'none';
            }
        } );

        async function getRelationships(entriesMap, path) {
            let xmlString = await getNormalizedXmlString(entriesMap, path);
            if (!xmlString) return {};

            const rels = {};
            // Use regex to parse relationships to be resilient to XML parsing errors.
            const relRegex = /<Relationship\s+([^>]+)\/?>/g;
            const attrRegex = /(\w+)="([^"]+)"/g;

            let match;
            while ((match = relRegex.exec(xmlString)) !== null) {
                const attrs = {};
                const attributesString = match[1];
                for (const attrMatch of attributesString.matchAll(attrRegex)) {
                    attrs[attrMatch[1]] = attrMatch[2];
                }

                if (attrs.Id && attrs.Type && attrs.Target) {
                    rels[attrs.Id] = {
                        id: attrs.Id,
                        type: attrs.Type,
                        target: attrs.Target
                    };
                }
            }
            return rels;
        }

        function getSlideOrder(xmlString) {
            const ids = [];
            const regex = /<[^>:]*:sldId[^>]+r:id="([^"]+)"/g;
            let match;
            while ((match = regex.exec(xmlString)) !== null) {
                ids.push(match[1]);
            }
            return ids;
        }

        function getSlideSize(xmlString) {
            // Two-step regex for robustness: first find the tag, then find the attributes within it.
            const sldSzTagMatch = xmlString.match(/<[^>:]*:sldSz\s+([^>]+)\/?>/);
            if (sldSzTagMatch) {
                const attrs = sldSzTagMatch[1];
                const cxMatch = attrs.match(/cx="([^"]+)"/);
                const cyMatch = attrs.match(/cy="([^"]+)"/);
                if (cxMatch && cyMatch) {
                    const cx = parseInt(cxMatch[1]);
                    const cy = parseInt(cyMatch[1]);
                    return { width: cx / EMU_PER_PIXEL, height: cy / EMU_PER_PIXEL };
                }
            }
            return { width: 960, height: 720 }; // Default size
        }

        function resolveFontFamily(finalRunProps, phType, slideContext) {
            const fontAlias = finalRunProps.font;
            const theme = slideContext.theme;

            if (fontAlias) {
                if (fontAlias === '+mj-lt') {
                    return theme?.fontScheme?.major || 'Arial';
                }
                if (fontAlias === '+mn-lt') {
                    return theme?.fontScheme?.minor || 'Arial';
                }
                return fontAlias; // It's a specific font like 'Calibri'
            }

            // No font in run, so fallback to placeholder type
            if (phType === 'title' || phType === 'ctrTitle' || phType === 'subTitle') {
                return theme?.fontScheme?.major || 'Arial';
            }

            return theme?.fontScheme?.minor || 'Arial';
        }

        function layoutParagraphs(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const paddedPos = {
                x: pos.x + (bodyPr.lIns || 0),
                y: pos.y + (bodyPr.tIns || 0),
                width: pos.width - (bodyPr.lIns || 0) - (bodyPr.rIns || 0),
                height: pos.height - (bodyPr.tIns || 0) - (bodyPr.bIns || 0),
            };

            const lines = [];
            let currentY = 0;

            for (const pNode of paragraphs) {
                const pPrNode = pNode.getElementsByTagNameNS(DML_NS, 'pPr')[0];
                const level = pPrNode ? parseInt(pPrNode.getAttribute('lvl') || '0') : 0;
                let defaultStyle = defaultTextStyles.other;
                if (phType === 'title' || phType === 'ctrTitle' || phType === 'subTitle') defaultStyle = defaultTextStyles.title;
                else if (phType === 'body') defaultStyle = defaultTextStyles.body;

                const defaultLevelProps = (defaultStyle && defaultStyle[level]) ? defaultStyle[level] : {};

                const masterPh = masterPlaceholders ? (masterPlaceholders[phKey] || Object.values(masterPlaceholders).find(p => p.type === phType)) : null;
                let masterListStyle = (masterPh?.listStyle?.[level]) || {};
                if (masterPh && masterPh.type && phType && masterPh.type !== phType) {
                    masterListStyle = {};
                }

                const layoutPh = layoutPlaceholders ? layoutPlaceholders[phKey] : null;
                let layoutListStyle = (layoutPh?.listStyle?.[level]) || {};
                if (layoutPh && layoutPh.type && phType && layoutPh.type !== phType) {
                    layoutListStyle = {};
                }
                const slideLevelProps = parseParagraphProperties(pPrNode) || { bullet: {}, defRPr: {} };

                const finalProps = {
                    level,
                    ...defaultLevelProps,
                    ...masterListStyle,
                    ...layoutListStyle,
                    ...slideLevelProps,
                    bullet: { ...defaultLevelProps.bullet, ...masterListStyle.bullet, ...layoutListStyle.bullet, ...slideLevelProps.bullet },
                    defRPr: { ...defaultLevelProps.defRPr, ...masterListStyle.defRPr, ...layoutListStyle.defRPr, ...slideLevelProps.defRPr }
                };

                const marL = (finalProps.marL !== undefined) ? finalProps.marL : (level > 0 ? (level * INDENTATION_AMOUNT) : 0);
                const indent = (finalProps.indent !== undefined) ? finalProps.indent : 0;
                const bulletOffset = (finalProps.bullet.type && finalProps.bullet.type !== 'none') ? BULLET_OFFSET : 0;

                let currentLine = { runs: [], width: 0, height: 0, paragraphProps: finalProps, startY: currentY, isFirstLine: true };

                const pushCurrentLine = () => {
                    if (currentLine.runs.length > 0) {
                        lines.push(currentLine);
                        currentY += currentLine.height || LINE_HEIGHT;
                    }
                    currentLine = { runs: [], width: 0, height: 0, paragraphProps: finalProps, startY: currentY, isFirstLine: false };
                };

                const runsAndBreaks = Array.from(pNode.childNodes).filter(n => ['r', 'fld', 'br'].includes(n.localName));

                for (const childNode of runsAndBreaks) {
                    if (childNode.localName === 'br') {
                        pushCurrentLine();
                        continue;
                    }

                    const text = childNode.textContent;
                    if (!text) continue;

                    const rPr = childNode.getElementsByTagNameNS(DML_NS, 'rPr')[0];
                    const finalRunProps = { ...finalProps.defRPr };
                    if (rPr) {
                        if (rPr.getAttribute('sz')) finalRunProps.size = (parseInt(rPr.getAttribute('sz')) / 100) * PT_TO_PX;
                        if (rPr.getAttribute('b') === '1') finalRunProps.bold = true; else if (rPr.getAttribute('b') === '0') finalRunProps.bold = false;
                        if (rPr.getAttribute('i') === '1') finalRunProps.italic = true; else if (rPr.getAttribute('i') === '0') finalRunProps.italic = false;
                        const solidFill = rPr.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                        if (solidFill) finalRunProps.color = parseColor(solidFill);
                        const latinFontNode = rPr.getElementsByTagNameNS(DML_NS, 'latin')[0];
                        if (latinFontNode && latinFontNode.getAttribute('typeface')) finalRunProps.font = latinFontNode.getAttribute('typeface');
                    }

                    const textColor = resolveColor(finalRunProps.color, slideContext) || '#000000';
                    let fontSize = finalRunProps.size || (18 * PT_TO_PX);
                    if (bodyPr.fontScale) {
                        fontSize *= bodyPr.fontScale;
                    }
                    const fontStyle = finalRunProps.italic ? 'italic' : 'normal';
                    const fontWeight = finalRunProps.bold ? 'bold' : 'normal';
                    const fontFamily = resolveFontFamily(finalRunProps, phType, slideContext);

                    const tempCtx = document.createElement('canvas').getContext('2d');
                    tempCtx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
                    const words = text.split(/(\s+)/); // Split on whitespace but keep it

                    for (const word of words) {
                        if (!word) continue;

                        const wordWidth = tempCtx.measureText(word).width;
                        const currentIndent = currentLine.isFirstLine ? marL + indent : marL;
                        const effectiveWidth = paddedPos.width - currentIndent - bulletOffset;

                        if (currentLine.width + wordWidth > effectiveWidth && currentLine.runs.length > 0) {
                            pushCurrentLine();
                        }

                        currentLine.runs.push({
                            text: word,
                            width: wordWidth,
                            font: {
                                style: fontStyle,
                                weight: fontWeight,
                                size: fontSize,
                                family: fontFamily
                            },
                            color: textColor
                        });
                        currentLine.width += wordWidth;
                        let lineHeight = fontSize * 1.2; // Approximate height
                        if (bodyPr.lnSpcReduction) {
                            lineHeight *= (1 - bodyPr.lnSpcReduction);
                        }
                        currentLine.height = Math.max(currentLine.height, lineHeight);
                    }
                }
                pushCurrentLine(); // Push the last line of the paragraph
            }

            const totalHeight = currentY;
            for(const line of lines) {
                const align = line.paragraphProps.align || 'l';
                const level = line.paragraphProps.level || 0;
                const marL = (line.paragraphProps.marL !== undefined) ? line.paragraphProps.marL : (level > 0 ? (level * INDENTATION_AMOUNT) : 0);
                const indent = (line.paragraphProps.indent !== undefined) ? line.paragraphProps.indent : 0;
                const bulletOffset = (line.paragraphProps.bullet.type && line.paragraphProps.bullet.type !== 'none') ? BULLET_OFFSET : 0;

                const lineIndent = line.isFirstLine ? marL + indent : marL;
                const effectiveWidth = paddedPos.width - lineIndent - bulletOffset;

                let lineXOffset = 0;
                if (align === 'ctr') {
                    lineXOffset = (effectiveWidth - line.width) / 2;
                } else if (align === 'r') {
                    lineXOffset = effectiveWidth - line.width;
                }
                line.x = paddedPos.x + lineIndent + bulletOffset + lineXOffset;
            }

            return { totalHeight, lines };
        }

        function getAutoNumberingChar(scheme, number) {
            switch (scheme) {
                case 'alphaLcParenBoth': return `(${String.fromCharCode(96 + number)})`;
                case 'alphaLcParenR': return `${String.fromCharCode(96 + number)})`;
                case 'alphaLcPeriod': return `${String.fromCharCode(96 + number)}.`;
                case 'alphaUcParenBoth': return `(${String.fromCharCode(64 + number)})`;
                case 'alphaUcParenR': return `${String.fromCharCode(64 + number)})`;
                case 'alphaUcPeriod': return `${String.fromCharCode(64 + number)}.`;
                case 'arabicParenBoth': return `(${number})`;
                case 'arabicParenR': return `${number})`;
                case 'arabicPeriod': return `${number}.`;
                case 'arabicPlain': return `${number}`;
                case 'romanLcParenBoth': return `(${integerToRoman(number).toLowerCase()})`;
                case 'romanLcParenR': return `${integerToRoman(number).toLowerCase()})`;
                case 'romanLcPeriod': return `${integerToRoman(number).toLowerCase()}.`;
                case 'romanUcParenBoth': return `(${integerToRoman(number)})`;
                case 'romanUcParenR': return `${integerToRoman(number)})`;
                case 'romanUcPeriod': return `${integerToRoman(number)}.`;
                default: return `${number}.`;
            }
        }

        function createImage(url) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = url;
            });
        }

        async function populateImageMap(imageMap, rels, baseDir, entriesMap) {
            const imageRels = Object.values(rels).filter(rel => rel.type.endsWith('/image'));
            for (const rel of imageRels) {
                // Do not overwrite an image that has already been loaded from a more specific source (e.g., slide vs layout)
                if (imageMap[rel.id]) {
                    continue;
                }

                const imagePath = resolvePath(baseDir, rel.target);
                const imageEntry = entriesMap.get(imagePath);
                if (imageEntry) {
                    try {
                        const writer = new BlobWriter();
                        const imageBlob = await imageEntry.getData(writer);
                        const reader = new FileReader();
                        const imageData = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result.split(',')[1]);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        imageMap[rel.id] = `data:image/png;base64,${imageData}`;
                    } catch (e) {
                        console.error(`Failed to load image data for relId ${rel.id} at path ${imagePath}`, e);
                    }
                } else {
                    console.warn(`Image relationship '${rel.id}' points to a non-existent target: ${rel.target} (resolved to ${imagePath})`);
                }
            }
        }

        function parseTheme(themeXml) {
            const xmlDoc = parseXmlString(themeXml, "theme");
            const theme = {
                colorScheme: {},
                fontScheme: {},
                formatScheme: {
                    fills: [],
                    lines: [],
                    effects: [],
                    bgFills: [],
                },
            };

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const clrSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'clrScheme')[0];
            if (clrSchemeNode) {
                for (const child of clrSchemeNode.children) {
                    const colorName = child.localName;
                    const srgbClrNode = child.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
                    if (srgbClrNode) {
                        theme.colorScheme[colorName] = `#${srgbClrNode.getAttribute('val')}`;
                    }
                    const sysClrNode = child.getElementsByTagNameNS(DML_NS, 'sysClr')[0];
                    if (sysClrNode) {
                        const lastColor = sysClrNode.getAttribute('lastClr');
                        if (lastColor) {
                            // Use lastClr as a fallback, it's often more reliable
                            theme.colorScheme[colorName] = `#${lastColor}`;
                        }
                        // If no lastClr, we don't set a color, letting it fall back to default.
                    }
                }
            }

            const fontSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'fontScheme')[0];
            if (fontSchemeNode) {
                const majorFontNode = fontSchemeNode.getElementsByTagNameNS(DML_NS, 'majorFont')[0];
                if (majorFontNode) {
                    const latinFontNode = majorFontNode.getElementsByTagNameNS(DML_NS, 'latin')[0];
                    if (latinFontNode) {
                        theme.fontScheme.major = latinFontNode.getAttribute('typeface');
                    }
                }
                const minorFontNode = fontSchemeNode.getElementsByTagNameNS(DML_NS, 'minorFont')[0];
                if (minorFontNode) {
                    const latinFontNode = minorFontNode.getElementsByTagNameNS(DML_NS, 'latin')[0];
                    if (latinFontNode) {
                        theme.fontScheme.minor = latinFontNode.getAttribute('typeface');
                    }
                }
            }

            const fmtSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'fmtScheme')[0];
            if (fmtSchemeNode) {
                const fillStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'fillStyleLst')[0];
                if (fillStyleLstNode) {
                    for (const fillNode of fillStyleLstNode.children) {
                        if (fillNode.localName === 'solidFill') {
                            const colorObj = parseColor(fillNode);
                            theme.formatScheme.fills.push({ type: 'solid', color: colorObj });
                        } else if (fillNode.localName === 'gradFill') {
                            const gsLstNode = fillNode.getElementsByTagNameNS(DML_NS, 'gsLst')[0];
                            const stops = [];
                            if (gsLstNode) {
                                for (const gsNode of gsLstNode.children) {
                                    const pos = parseInt(gsNode.getAttribute('pos')) / 1000; // Position is in 1000ths of a percent
                                    const colorObj = parseColor(gsNode);
                                    if (colorObj) {
                                        stops.push({ pos, color: colorObj });
                                    }
                                }
                            }
                            let angle = 0;
                            const linNode = fillNode.getElementsByTagNameNS(DML_NS, 'lin')[0];
                            if (linNode) {
                                angle = parseInt(linNode.getAttribute('ang')) / 60000; // Angle is in 60000ths of a degree
                            }
                            theme.formatScheme.fills.push({ type: 'gradient', stops, angle });
                        } else if (fillNode.localName === 'blipFill') {
                            const blipNode = fillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                            if (blipNode) {
                                const relId = blipNode.getAttribute('r:embed');
                                theme.formatScheme.fills.push({ type: 'image', relId: relId });
                            }
                        } else if (fillNode.localName === 'pattFill') {
                            const pattern = {
                                type: 'pattern',
                                pattern: fillNode.getAttribute('prst'),
                                fgColor: null,
                                bgColor: null,
                            };
                            const fgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'fgClr')[0];
                            if (fgClrNode) {
                                pattern.fgColor = parseColor(fgClrNode);
                            }
                            const bgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'bgClr')[0];
                            if (bgClrNode) {
                                pattern.bgColor = parseColor(bgClrNode);
                            }
                            theme.formatScheme.fills.push(pattern);
                        } else if (fillNode.localName === 'grpFill') {
                            theme.formatScheme.fills.push({ type: 'group' });
                        } else if (fillNode.localName === 'noFill') {
                            theme.formatScheme.fills.push({ type: 'none' });
                        } else {
                            theme.formatScheme.fills.push({ type: 'unsupported' });
                        }
                    }
                }

                const lnStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'lnStyleLst')[0];
                if (lnStyleLstNode) {
                    for (const lineNode of lnStyleLstNode.children) {
                        const width = parseInt(lineNode.getAttribute('w') || '9525');
                        const cap = lineNode.getAttribute('cap');
                        const cmpd = lineNode.getAttribute('cmpd');

                        const solidFillNode = lineNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                        if (solidFillNode) {
                            const colorObj = parseColor(solidFillNode);
                            theme.formatScheme.lines.push({ type: 'solid', color: colorObj, width: width / EMU_PER_PIXEL, cap, cmpd });
                        } else {
                            theme.formatScheme.lines.push({ type: 'unsupported' });
                        }
                    }
                }

                 const effectStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'effectStyleLst')[0];
                 if (effectStyleLstNode) {
                    for (const effectStyleNode of effectStyleLstNode.children) {
                        if (effectStyleNode.localName === 'effectStyle') {
                            const effectLstNode = effectStyleNode.getElementsByTagNameNS(DML_NS, 'effectLst')[0];
                            if (effectLstNode) {
                                const outerShdwNode = effectLstNode.getElementsByTagNameNS(DML_NS, 'outerShdw')[0];
                                if (outerShdwNode) {
                                    const blurRad = parseInt(outerShdwNode.getAttribute('blurRad') || '0') / EMU_PER_PIXEL;
                                    const dist = parseInt(outerShdwNode.getAttribute('dist') || '0') / EMU_PER_PIXEL;
                                    const dir = parseInt(outerShdwNode.getAttribute('dir') || '0') / 60000;
                                    const color = parseColor(outerShdwNode);
                                    theme.formatScheme.effects.push({
                                        type: 'outerShdw',
                                        blurRad,
                                        dist,
                                        dir,
                                        color,
                                    });
                                } else {
                                    // Placeholder for other or no effects
                                    theme.formatScheme.effects.push(null);
                                }
                            } else {
                                theme.formatScheme.effects.push(null);
                            }
                        }
                    }
                 }

                const bgFillStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'bgFillStyleLst')[0];
                if (bgFillStyleLstNode) {
                    for (const fillNode of bgFillStyleLstNode.children) {
                        if (fillNode.localName === 'solidFill') {
                            const colorObj = parseColor(fillNode);
                            theme.formatScheme.bgFills.push({ type: 'solid', color: colorObj });
                        } else if (fillNode.localName === 'gradFill') {
                            const gsLstNode = fillNode.getElementsByTagNameNS(DML_NS, 'gsLst')[0];
                            const stops = [];
                            if (gsLstNode) {
                                for (const gsNode of gsLstNode.children) {
                                    const pos = parseInt(gsNode.getAttribute('pos')) / 1000; // Position is in 1000ths of a percent
                                    const colorObj = parseColor(gsNode);
                                    if (colorObj) {
                                        stops.push({ pos, color: colorObj });
                                    }
                                }
                            }
                            let angle = 0;
                            const linNode = fillNode.getElementsByTagNameNS(DML_NS, 'lin')[0];
                            if (linNode) {
                                angle = parseInt(linNode.getAttribute('ang')) / 60000; // Angle is in 60000ths of a degree
                            }
                            theme.formatScheme.bgFills.push({ type: 'gradient', stops, angle });
                        } else if (fillNode.localName === 'blipFill') {
                            const blipNode = fillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                            if (blipNode) {
                                const relId = blipNode.getAttribute('r:embed');
                                theme.formatScheme.bgFills.push({ type: 'image', relId: relId });
                            }
                        } else if (fillNode.localName === 'pattFill') {
                            const pattern = {
                                type: 'pattern',
                                pattern: fillNode.getAttribute('prst'),
                                fgColor: null,
                                bgColor: null,
                            };
                            const fgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'fgClr')[0];
                            if (fgClrNode) {
                                pattern.fgColor = parseColor(fgClrNode);
                            }
                            const bgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'bgClr')[0];
                            if (bgClrNode) {
                                pattern.bgColor = parseColor(bgClrNode);
                            }
                            theme.formatScheme.bgFills.push(pattern);
                        } else if (fillNode.localName === 'grpFill') {
                            theme.formatScheme.bgFills.push({ type: 'group' });
                        } else if (fillNode.localName === 'noFill') {
                            theme.formatScheme.bgFills.push({ type: 'none' });
                        } else {
                            theme.formatScheme.bgFills.push({ type: 'unsupported' });
                        }
                    }
                }
            }

            return theme;
        }

        function parseColorMap(node) {
            const colorMap = {};
            if (node) {
                for (const { name, value } of node.attributes) {
                    colorMap[name] = value;
                }
            }
            return colorMap;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (Math.floor(r) << 16) + (Math.floor(g) << 8) + Math.floor(b)).toString(16).slice(1).toUpperCase();
        }

        function applyTint(hex, tint) {
            const base = hexToRgb(hex);
            if (!base) return hex;
            const amount = tint / 100000; // Tint is provided as e.g. 80000 for 80%
            const r = base.r * (1 - amount) + 255 * amount;
            const g = base.g * (1 - amount) + 255 * amount;
            const b = base.b * (1 - amount) + 255 * amount;
            return rgbToHex(r, g, b);
        }

        function applyShade(hex, shade) {
            const base = hexToRgb(hex);
            if (!base) return hex;
            const amount = shade / 100000; // Shade is provided as e.g. 80000 for 80%
            const r = base.r * (1 - amount);
            const g = base.g * (1 - amount);
            const b = base.b * (1 - amount);
            return rgbToHex(r, g, b);
        }

        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        function applyLuminance(hex, lumMod, lumOff) {
            const rgb = hexToRgb(hex);
            if (!rgb) return hex;

            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            let newL = hsl.l;

            if (lumMod) {
                newL *= (lumMod / 100000);
            }
            if (lumOff) {
                newL += (lumOff / 100000);
            }

            // Clamp luminance to the valid range [0, 1]
            newL = Math.max(0, Math.min(1, newL));

            const newRgb = hslToRgb(hsl.h, hsl.s, newL);
            return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
        }

        function parseColor(colorNode) {
            if (!colorNode) return null;

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const srgbClrNode = colorNode.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
            if (srgbClrNode) {
                const color = { srgb: `#${srgbClrNode.getAttribute('val')}` };
                const alphaNode = srgbClrNode.getElementsByTagNameNS(DML_NS, 'alpha')[0];
                if (alphaNode) color.alpha = parseInt(alphaNode.getAttribute('val'));
                return color;
            }

            const schemeClrNode = colorNode.getElementsByTagNameNS(DML_NS, 'schemeClr')[0];
            if (schemeClrNode) {
                const color = { scheme: schemeClrNode.getAttribute('val') };
                const tintNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'tint')[0];
                if (tintNode) color.tint = parseInt(tintNode.getAttribute('val'));

                const shadeNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'shade')[0];
                if (shadeNode) color.shade = parseInt(shadeNode.getAttribute('val'));

                const alphaNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'alpha')[0];
                if (alphaNode) color.alpha = parseInt(alphaNode.getAttribute('val'));

                const lumModNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'lumMod')[0];
                if (lumModNode) color.lumMod = parseInt(lumModNode.getAttribute('val'));

                const lumOffNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'lumOff')[0];
                if (lumOffNode) color.lumOff = parseInt(lumOffNode.getAttribute('val'));

                return color;
            }

            return null;
        }

        function resolveColor(colorObj, slideContext) {
            if (!colorObj || !slideContext.theme) {
                return null;
            }

            let hex;
            if (colorObj.srgb) {
                hex = colorObj.srgb;
            } else if (colorObj.scheme) {
                let themeColorName = slideContext.colorMap[colorObj.scheme] || colorObj.scheme;
                if (themeColorName === 'phClr') {
                    // phClr is context-dependent. For a robust default, we'll map it
                    // to a visible accent color like accent1.
                    themeColorName = 'accent1';
                }
                if (themeColorName && slideContext.theme.colorScheme[themeColorName]) {
                    hex = slideContext.theme.colorScheme[themeColorName];
                    if (colorObj.tint) hex = applyTint(hex, colorObj.tint);
                    if (colorObj.shade) hex = applyShade(hex, colorObj.shade);
                    if (colorObj.lumMod || colorObj.lumOff) hex = applyLuminance(hex, colorObj.lumMod, colorObj.lumOff);
                }
            }

            if (hex) {
                if (colorObj.alpha) {
                    const rgb = hexToRgb(hex);
                    if (rgb) {
                        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${colorObj.alpha / 100000})`;
                    }
                }
                return hex;
            }

            return null; // Return null if color can't be resolved
        }

        function parseTableStyles(xmlString) {
            const xmlDoc = parseXmlString(xmlString, "tableStyles");
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const styles = {};

            const tblStyleLstNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'tblStyleLst')[0];
            const defaultStyleId = tblStyleLstNode ? tblStyleLstNode.getAttribute('def') : null;

            const tblStyleNodes = xmlDoc.getElementsByTagNameNS(DML_NS, 'tblStyle');

            for (const styleNode of tblStyleNodes) {
                const styleId = styleNode.getAttribute('styleId');
                const styleDef = {};

                const styleParts = ['wholeTbl', 'band1H', 'band2H', 'band1V', 'band2V', 'firstRow', 'lastRow', 'firstCol', 'lastCol', 'nwCell', 'neCell', 'swCell', 'seCell'];

                for (const partName of styleParts) {
                    const partNode = styleNode.getElementsByTagNameNS(DML_NS, partName)[0];
                    if (partNode) {
                        styleDef[partName] = parseStylePart(partNode);
                    }
                }
                styles[styleId] = styleDef;
            }

            return { styles, defaultStyleId };
        }

        function parseStylePart(partNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const partDef = {
                tcStyle: {},
                tcTxStyle: {}
            };

            const tcStyleNode = partNode.getElementsByTagNameNS(DML_NS, 'tcStyle')[0];
            if (tcStyleNode) {
                const fillNode = tcStyleNode.getElementsByTagNameNS(DML_NS, 'fill')[0];
                if (fillNode) {
                    const solidFillNode = fillNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                    if (solidFillNode) {
                        partDef.tcStyle.fill = parseColor(solidFillNode);
                    }
                }

                const tcBdrNode = tcStyleNode.getElementsByTagNameNS(DML_NS, 'tcBdr')[0];
                if (tcBdrNode) {
                    partDef.tcStyle.borders = {};
                    const borderTypes = ['left', 'right', 'top', 'bottom'];
                    for (const type of borderTypes) {
                        const borderNode = tcBdrNode.getElementsByTagNameNS(DML_NS, type)[0];
                        if (borderNode) {
                            const lnNode = borderNode.getElementsByTagNameNS(DML_NS, 'ln')[0];
                            if (lnNode) {
                                const width = parseInt(lnNode.getAttribute('w') || '9525') / EMU_PER_PIXEL;
                                const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                                if (solidFillNode) {
                                    const colorObj = parseColor(solidFillNode);
                                    if (colorObj) {
                                        partDef.tcStyle.borders[type] = {
                                            width: width,
                                            color: colorObj
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }

            const tcTxStyleNode = partNode.getElementsByTagNameNS(DML_NS, 'tcTxStyle')[0];
            if (tcTxStyleNode) {
                // TODO: Parse text styles for tables (bold, italic, color, etc.)
            }

            return partDef;
        }

        function parseBackground(xmlDoc, slideContext) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const bgNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'bg')[0];
            if (!bgNode) return null;

            const bgPrNode = bgNode.getElementsByTagNameNS(PML_NS, 'bgPr')[0];
            if (bgPrNode) {
                const solidFillNode = bgPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                if (solidFillNode) {
                    const colorObj = parseColor(solidFillNode);
                    if (colorObj) {
                        return { type: 'color', value: resolveColor(colorObj, slideContext) };
                    }
                }

                const blipFillNode = bgPrNode.getElementsByTagNameNS(DML_NS, 'blipFill')[0];
                if (blipFillNode) {
                    const blipNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                    if (blipNode) {
                        const relId = blipNode.getAttribute('r:embed');
                        return { type: 'image', relId: relId };
                    }
                }
            }

            return null;
        }

        function parseCustomGeometry(custGeomNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const pathLstNode = custGeomNode.getElementsByTagNameNS(DML_NS, 'pathLst')[0];
            if (!pathLstNode) return null;

            const pathNode = pathLstNode.getElementsByTagNameNS(DML_NS, 'path')[0];
            if (!pathNode) return null;

            const pathW = parseInt(pathNode.getAttribute('w'));
            const pathH = parseInt(pathNode.getAttribute('h'));
            const commands = [];

            for (const cmdNode of pathNode.children) {
                const cmd = cmdNode.localName;
                const ptNodes = cmdNode.getElementsByTagNameNS(DML_NS, 'pt');
                const points = Array.from(ptNodes).map(pt => ({
                    x: parseInt(pt.getAttribute('x')),
                    y: parseInt(pt.getAttribute('y')),
                }));

                // close doesn't have points, handle it separately
                if (cmd === 'close') {
                    commands.push({ cmd: 'close', points: [] });
                } else {
                    commands.push({ cmd, points });
                }
            }

            if (commands.length === 0) return null;

            return {
                commands: commands,
                w: pathW,
                h: pathH,
            };
        }

        function parseLineProperties(lnNode, slideContext) {
            if (!lnNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const noFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
            if (noFillNode) return null;

            const capMap = {
                rnd: 'round',
                sq: 'square',
                flat: 'butt'
            };

            const props = {
                width: parseInt(lnNode.getAttribute('w') || '9525') / EMU_PER_PIXEL,
                cap: capMap[lnNode.getAttribute('cap')] || 'butt',
                join: null, // miter, round, bevel
                cmpd: lnNode.getAttribute('cmpd'),
            };

            const roundNode = lnNode.getElementsByTagNameNS(DML_NS, 'round')[0];
            if (roundNode) props.join = 'round';

            const bevelNode = lnNode.getElementsByTagNameNS(DML_NS, 'bevel')[0];
            if (bevelNode) props.join = 'bevel';

            const miterNode = lnNode.getElementsByTagNameNS(DML_NS, 'miter')[0];
            if (miterNode) props.join = 'miter';

            const prstDashNode = lnNode.getElementsByTagNameNS(DML_NS, 'prstDash')[0];
            if (prstDashNode) {
                const dashType = prstDashNode.getAttribute('val') || 'solid';
                const w = props.width;
                switch (dashType) {
                    case 'solid':
                        props.dash = [];
                        break;
                    case 'dot':
                        props.dash = [w, 3 * w];
                        break;
                    case 'dash':
                        props.dash = [3 * w, 4 * w];
                        break;
                    case 'lgDash':
                        props.dash = [8 * w, 3 * w];
                        break;
                    case 'dashDot':
                        props.dash = [4 * w, 3 * w, w, 3 * w];
                        break;
                    case 'lgDashDot':
                        props.dash = [8 * w, 3 * w, w, 3 * w];
                        break;
                    case 'lgDashDotDot':
                        props.dash = [8 * w, 3 * w, w, 3 * w, w, 3 * w];
                        break;
                    case 'sysDash':
                        props.dash = [3 * w, w];
                        break;
                    case 'sysDot':
                        props.dash = [w, w];
                        break;
                    case 'sysDashDot':
                        props.dash = [3 * w, w, w, w];
                        break;
                    case 'sysDashDotDot':
                        props.dash = [3 * w, w, w, w, w, w];
                        break;
                    default:
                        props.dash = [];
                        break;
                }
            }

            const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
            if (solidFillNode) {
                props.color = resolveColor(parseColor(solidFillNode), slideContext);
            }

            return props;
        }

        function parseShapeProperties(shapeNode, slideContext, slideNum) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const spPrNode = shapeNode.getElementsByTagNameNS(PML_NS, 'spPr')[0];
            if (!spPrNode) return { fill: null, stroke: null, geometry: null, rawFillNode: null, rawStrokeNode: null, effect: null };

            const properties = { fill: null, stroke: null, geometry: null, rawFillNode: null, rawStrokeNode: null, effect: null };

            const prstGeomNode = spPrNode.getElementsByTagNameNS(DML_NS, 'prstGeom')[0];
            if (prstGeomNode) {
                const avLstNode = prstGeomNode.getElementsByTagNameNS(DML_NS, 'avLst')[0];
                const adjustments = {};
                if (avLstNode) {
                    const gdNodes = avLstNode.getElementsByTagNameNS(DML_NS, 'gd');
                    for (const gdNode of gdNodes) {
                        const name = gdNode.getAttribute('name');
                        const fmla = gdNode.getAttribute('fmla');
                        if (fmla.startsWith('val ')) {
                            adjustments[name] = parseInt(fmla.substring(4));
                        }
                    }
                }
                properties.geometry = {
                    type: 'preset',
                    preset: prstGeomNode.getAttribute('prst'),
                    adjustments: adjustments,
                };
            }

            const custGeomNode = spPrNode.getElementsByTagNameNS(DML_NS, 'custGeom')[0];
            if (custGeomNode) {
                properties.geometry = { type: 'custom', path: parseCustomGeometry(custGeomNode) };
            }

            // --- Fill Parsing ---
            let fillNode = null;
            const fillTypes = ['solidFill', 'gradFill', 'noFill', 'blipFill', 'pattFill', 'grpFill'];
            for (const child of spPrNode.children) {
                if (fillTypes.includes(child.localName)) {
                    fillNode = child;
                    break;
                }
            }

            if (fillNode) {
                properties.rawFillNode = fillNode.outerHTML;
                if (fillNode.localName === 'noFill') {
                    properties.fill = 'none';
                } else if (fillNode.localName === 'solidFill') {
                    const colorObj = parseColor(fillNode);
                    if (colorObj) properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                } else if (fillNode.localName === 'gradFill') {
                    // Gradient parsing logic...
                }
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const fillRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'fillRef')[0];
                    if (fillRefNode) {
                        properties.rawFillNode = fillRefNode.outerHTML;
                        const idx = parseInt(fillRefNode.getAttribute('idx'));
                        const colorOverride = parseColor(fillRefNode);
                        if (idx > 0 && slideContext.theme.formatScheme.fills[idx - 1]) {
                            const themeFill = slideContext.theme.formatScheme.fills[idx - 1];
                            let colorObj = colorOverride || themeFill.color;
                            if (themeFill.type === 'solid') {
                                properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                            }
                        } else if (colorOverride) {
                            properties.fill = { type: 'solid', color: resolveColor(colorOverride, slideContext) };
                        }
                    }
                }
            }

            // --- Stroke Parsing ---
            const lnNode = spPrNode.getElementsByTagNameNS(DML_NS, 'ln')[0];
            if (lnNode) {
                properties.rawStrokeNode = lnNode.outerHTML;
                properties.stroke = parseLineProperties(lnNode, slideContext);
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const lnRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'lnRef')[0];
                    if (lnRefNode) {
                        properties.rawStrokeNode = lnRefNode.outerHTML;
                        const idx = parseInt(lnRefNode.getAttribute('idx'));
                        if (idx > 0 && slideContext.theme.formatScheme.lines[idx - 1]) {
                            const themeLine = slideContext.theme.formatScheme.lines[idx - 1];
                            if (themeLine.type === 'solid') {
                                const strokeProps = { ...themeLine };
                                const lnRefColorObj = parseColor(lnRefNode);
                                if (lnRefColorObj) {
                                    strokeProps.color = resolveColor(lnRefColorObj, slideContext);
                                } else {
                                    strokeProps.color = resolveColor(themeLine.color, slideContext);
                                }
                                properties.stroke = strokeProps;
                            }
                        }
                    }
                }
            }

            // --- Effect Parsing ---
            const effectLstNode = spPrNode.getElementsByTagNameNS(DML_NS, 'effectLst')[0];
            if (effectLstNode) {
                const outerShdwNode = effectLstNode.getElementsByTagNameNS(DML_NS, 'outerShdw')[0];
                if (outerShdwNode) {
                    const blurRad = parseInt(outerShdwNode.getAttribute('blurRad') || '0') / EMU_PER_PIXEL;
                    const dist = parseInt(outerShdwNode.getAttribute('dist') || '0') / EMU_PER_PIXEL;
                    const dir = parseInt(outerShdwNode.getAttribute('dir') || '0') / 60000;
                    const colorObj = parseColor(outerShdwNode);
                    properties.effect = {
                        type: 'outerShdw',
                        blurRad,
                        dist,
                        dir,
                        color: resolveColor(colorObj, slideContext),
                    };
                }
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const effectRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'effectRef')[0];
                    if (effectRefNode) {
                        const idx = parseInt(effectRefNode.getAttribute('idx'));
                        if (idx > 0 && slideContext.theme.formatScheme.effects[idx - 1]) {
                            properties.effect = slideContext.theme.formatScheme.effects[idx - 1];
                            // Apply color override if present
                            const colorOverride = parseColor(effectRefNode);
                            if (properties.effect && colorOverride) {
                                properties.effect.color = resolveColor(colorOverride, slideContext);
                            }
                        }
                    }
                }
            }

            // --- Default Fill Logic ---
            if (properties.fill === null && shapeNode.localName !== 'cxnSp') {
                 if (!properties.rawFillNode) { // Only apply default if no fill was specified at all
                    if (slideContext.theme && slideContext.theme.formatScheme.fills.length > 0) {
                        const defaultFill = slideContext.theme.formatScheme.fills[1] || slideContext.theme.formatScheme.fills[0]; // Often the second fill is the default shape fill
                        if (defaultFill.type === 'solid' && defaultFill.color) {
                            properties.fill = { type: 'solid', color: resolveColor(defaultFill.color, slideContext) };
                        }
                    }
                 }
            }
            return properties;
        }

        function parseTextStyle(styleNode) {
            if (!styleNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const styles = {};
            for (let i = 1; i <= 9; i++) {
                const lvlPr = styleNode.getElementsByTagNameNS(DML_NS, `lvl${i}pPr`)[0];
                if (lvlPr) {
                    styles[i - 1] = parseParagraphProperties(lvlPr);
                }
            }
            return styles;
        }

        function parseBodyProperties(txBodyNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const bodyPrNode = txBodyNode ? txBodyNode.getElementsByTagNameNS(DML_NS, 'bodyPr')[0] : null;

            if (!bodyPrNode) return {};

            const props = {};
            const anchor = bodyPrNode.getAttribute('anchor');
            if (anchor) props.anchor = anchor;

            const lIns = bodyPrNode.getAttribute('lIns');
            if (lIns) props.lIns = parseInt(lIns) / EMU_PER_PIXEL;

            const tIns = bodyPrNode.getAttribute('tIns');
            if (tIns) props.tIns = parseInt(tIns) / EMU_PER_PIXEL;

            const rIns = bodyPrNode.getAttribute('rIns');
            if (rIns) props.rIns = parseInt(rIns) / EMU_PER_PIXEL;

            const bIns = bodyPrNode.getAttribute('bIns');
            if (bIns) props.bIns = parseInt(bIns) / EMU_PER_PIXEL;

            const normAutofitNode = bodyPrNode.getElementsByTagNameNS(DML_NS, 'normAutofit')[0];
            if (normAutofitNode) {
                const fontScale = normAutofitNode.getAttribute('fontScale');
                if (fontScale) {
                    props.fontScale = parseInt(fontScale) / 100000;
                }
                const lnSpcReduction = normAutofitNode.getAttribute('lnSpcReduction');
                if (lnSpcReduction) {
                    props.lnSpcReduction = parseInt(lnSpcReduction) / 100000;
                }
            }

            return props;
        }

        function parseParagraphProperties(pPrNode) {
            if (!pPrNode) return {};

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const properties = { bullet: {}, defRPr: {} };

            const align = pPrNode.getAttribute('algn');
            if (align) properties.align = align;

            const marL = pPrNode.getAttribute('marL');
            if (marL) properties.marL = parseInt(marL) / EMU_PER_PIXEL;

            const indent = pPrNode.getAttribute('indent');
            if (indent) properties.indent = parseInt(indent) / EMU_PER_PIXEL;

            const buNone = pPrNode.getElementsByTagNameNS(DML_NS, 'buNone')[0];
            if (buNone) properties.bullet.type = 'none';

            const buChar = pPrNode.getElementsByTagNameNS(DML_NS, 'buChar')[0];
            if (buChar) {
                properties.bullet.type = 'char';
                properties.bullet.char = buChar.getAttribute('char');
            }

            const buFont = pPrNode.getElementsByTagNameNS(DML_NS, 'buFont')[0];
            if (buFont) {
                properties.bullet.font = buFont.getAttribute('typeface');
            }

            const buAutoNum = pPrNode.getElementsByTagNameNS(DML_NS, 'buAutoNum')[0];
            if (buAutoNum) {
                properties.bullet.type = 'auto';
                properties.bullet.scheme = buAutoNum.getAttribute('type');
                properties.bullet.startAt = parseInt(buAutoNum.getAttribute('startAt') || '1');
            }

            const buBlip = pPrNode.getElementsByTagNameNS(DML_NS, 'buBlip')[0];
            if (buBlip) {
                const blip = buBlip.getElementsByTagNameNS(DML_NS, 'blip')[0];
                if (blip) {
                    properties.bullet.type = 'image';
                    properties.bullet.relId = blip.getAttribute('r:embed');
                }
            }

            const buSzPct = pPrNode.getElementsByTagNameNS(DML_NS, 'buSzPct')[0];
            if (buSzPct) {
                properties.bullet.size = `${parseInt(buSzPct.getAttribute('val')) / 1000}%`;
            }

            const buSzPts = pPrNode.getElementsByTagNameNS(DML_NS, 'buSzPts')[0];
            if (buSzPts) {
                properties.bullet.size = `${parseInt(buSzPts.getAttribute('val')) / 100}pt`;
            }

            const buClr = pPrNode.getElementsByTagNameNS(DML_NS, 'buClr')[0];
            if (buClr) {
                // Here, the color element is not a solidFill, but a direct child
                const srgbClr = buClr.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
                if (srgbClr) {
                    properties.bullet.color = { srgb: `#${srgbClr.getAttribute('val')}` };
                }
                const schemeClr = buClr.getElementsByTagNameNS(DML_NS, 'schemeClr')[0];
                if (schemeClr) {
                    properties.bullet.color = parseColor(buClr);
                }
            }

            const defRPrNode = pPrNode.getElementsByTagNameNS(DML_NS, 'defRPr')[0];
            if (defRPrNode) {
                const sz = defRPrNode.getAttribute('sz');
                if (sz) {
                    properties.defRPr.size = (parseInt(sz) / 100) * PT_TO_PX;
                }
                properties.defRPr.bold = defRPrNode.getAttribute('b') === '1';
                properties.defRPr.italic = defRPrNode.getAttribute('i') === '1';

                const solidFillNode = defRPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                if (solidFillNode) {
                    properties.defRPr.color = parseColor(solidFillNode);
                }

                const latinFontNode = defRPrNode.getElementsByTagNameNS( DML_NS, 'latin' )[ 0 ];
                if ( latinFontNode && latinFontNode.getAttribute( 'typeface' ) ) {
                    properties.defRPr.font = latinFontNode.getAttribute( 'typeface' );
                }
            }

            return properties;
        }

        function parseMasterOrLayout(xml, theme, masterColorMap = null, isLayout = false) {
            const xmlDoc = parseXmlString(xml, isLayout ? "slideLayout" : "slideMaster");
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const placeholders = {};
            const staticShapes = [];
            const defaultTextStyles = {};
            let colorMap = null;
            let colorMapOverride = null;

            if (isLayout) {
                const clrMapOvrNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'clrMapOvr')[0];
                if (clrMapOvrNode) {
                    const overrideNode = clrMapOvrNode.getElementsByTagNameNS(DML_NS, 'overrideClrMapping')[0];
                    if (overrideNode) {
                        colorMapOverride = parseColorMap(overrideNode);
                    }
                }
            } else {
                const clrMapNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'clrMap')[0];
                colorMap = parseColorMap(clrMapNode);
            }

            const txStyles = xmlDoc.getElementsByTagNameNS(PML_NS, 'txStyles')[0];
            if (txStyles) {
                defaultTextStyles.title = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'titleStyle')[0]);
                defaultTextStyles.body = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'bodyStyle')[0]);
                defaultTextStyles.other = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'otherStyle')[0]);
            }

            const spTreeNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'spTree')[0];
            if (spTreeNode) {
                for (const shapeNode of spTreeNode.children) {
                    const supportedNodes = ['sp', 'cxnSp', 'grpSp', 'graphicFrame', 'pic'];
                    if (!supportedNodes.includes(shapeNode.localName)) {
                        continue;
                    }

                    const nvPr = shapeNode.getElementsByTagNameNS(PML_NS, 'nvPr')[0];
                    const ph = nvPr ? nvPr.getElementsByTagNameNS(PML_NS, 'ph')[0] : null;

                    if (ph) {
                        const type = ph.getAttribute('type');
                        const idx = ph.getAttribute('idx');
                        const key = idx ? `idx_${idx}` : type;

                        // Always create a placeholder entry for shapes with a <p:ph> tag.
                        // The position will be added only if it exists.
                        const placeholderData = {
                            pos: null,
                            type: type,
                            listStyle: null,
                            shapeProps: {},
                            bodyPr: {}
                        };

                        const xfrmNode = shapeNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
                        if (xfrmNode) {
                            const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                            const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                            if (offNode && extNode) {
                                placeholderData.pos = {
                                    x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                                    y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                                    width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                                    height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                                };
                            }
                        }

                        const txBodyNode = shapeNode.getElementsByTagNameNS(PML_NS, 'txBody')[0];
                        if (txBodyNode) {
                            const lstStyleNode = txBodyNode.getElementsByTagNameNS(DML_NS, 'lstStyle')[0];
                            if (lstStyleNode) {
                                placeholderData.listStyle = parseTextStyle(lstStyleNode);
                            }
                            placeholderData.bodyPr = parseBodyProperties(txBodyNode);
                        }

                        const tempSlideContext = {
                            theme: theme,
                            colorMap: isLayout ? { ...(masterColorMap || {}), ...(colorMapOverride || {}) } : colorMap,
                        };
                        placeholderData.shapeProps = parseShapeProperties(shapeNode, tempSlideContext, "layout/master");

                        placeholders[key] = placeholderData;

                        if (type === 'pic') {
                            staticShapes.push(shapeNode);
                        }
                    } else {
                        staticShapes.push(shapeNode);
                    }
                }
            }
            return { placeholders, staticShapes, defaultTextStyles, colorMap, colorMapOverride };
        }

        function calculateTextBlockSize(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr) {
            const layout = layoutParagraphs(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr);
            return { height: layout.totalHeight };
        }

        async function processParagraphs(renderer, txBody, pos, phKey, phType, slideContext, imageMap, listCounters, defaultTextStyles, masterPlaceholders, layoutPlaceholders, bodyPr = {}) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const paragraphs = Array.from(txBody.getElementsByTagNameNS(DML_NS, 'p'));
            if (paragraphs.length === 0) return;

            const layout = layoutParagraphs(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr);

            const paddedPos = {
                x: pos.x + (bodyPr.lIns || 0),
                y: pos.y + (bodyPr.tIns || 0),
                width: pos.width - (bodyPr.lIns || 0) - (bodyPr.rIns || 0),
                height: pos.height - (bodyPr.tIns || 0) - (bodyPr.bIns || 0),
            };

            let startY = paddedPos.y;
            const anchor = bodyPr.anchor || 't';
            if (anchor === 'ctr') {
                startY += (paddedPos.height - layout.totalHeight) / 2;
            } else if (anchor === 'b') {
                startY += paddedPos.height - layout.totalHeight;
            }

            const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            for (const line of layout.lines) {
                const finalProps = line.paragraphProps;
                const bulletOffset = (finalProps.bullet.type && finalProps.bullet.type !== 'none') ? BULLET_OFFSET : 0;

                if (bulletOffset > 0 && line.isFirstLine) {
                    const bulletColor = resolveColor(finalProps.bullet.color, slideContext) || resolveColor(finalProps.defRPr.color, slideContext) || '#000';
                    const firstRunSize = line.runs.length > 0 ? line.runs[0].font.size : (finalProps.defRPr.size || 18 * PT_TO_PX);
                    const bulletBaselineY = startY + line.startY + firstRunSize;

                    if (finalProps.bullet.type === 'char') {
                        const bulletFontSize = finalProps.defRPr.size || (18 * PT_TO_PX);
                        const bulletText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        bulletText.setAttribute('x', line.x - bulletOffset);
                        bulletText.setAttribute('y', bulletBaselineY);
                        bulletText.setAttribute('fill', bulletColor);
                        bulletText.setAttribute('font-size', `${bulletFontSize}px`);
                        bulletText.setAttribute('font-family', finalProps.bullet.font || 'Arial');
                        bulletText.textContent = finalProps.bullet.char;
                        textGroup.appendChild(bulletText);
                    } else if (finalProps.bullet.type === 'auto') {
                        const level = finalProps.level || 0;
                        if (listCounters[level] === undefined) listCounters[level] = finalProps.bullet.startAt || 1; else listCounters[level]++;
                        const bulletChar = getAutoNumberingChar(finalProps.bullet.scheme, listCounters[level]);
                        const bulletFontSize = finalProps.defRPr.size || (18 * PT_TO_PX);
                        const bulletText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        bulletText.setAttribute('x', line.x - bulletOffset);
                        bulletText.setAttribute('y', bulletBaselineY);
                        bulletText.setAttribute('fill', bulletColor);
                        bulletText.setAttribute('font-size', `${bulletFontSize}px`);
                        bulletText.setAttribute('font-family', finalProps.bullet.font || 'Arial');
                        bulletText.textContent = bulletChar;
                        textGroup.appendChild(bulletText);
                    } else if (finalProps.bullet.type === 'image' && finalProps.bullet.relId && imageMap[finalProps.bullet.relId]) {
                        const imageY = bulletBaselineY - 8; // Approximation
                        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        image.setAttribute('x', line.x - bulletOffset);
                        image.setAttribute('y', imageY);
                        image.setAttribute('width', 16);
                        image.setAttribute('height', 16);
                        image.setAttribute('href', imageMap[finalProps.bullet.relId]);
                        textGroup.appendChild(image);
                    }
                }

                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                let align = finalProps.align || 'l';
                if (bodyPr.anchor === 'ctr' && !finalProps.align) {
                    align = 'ctr';
                }
                const xPos = line.x;

                if (align === 'ctr') {
                    textElement.setAttribute('x', xPos + line.width / 2);
                    textElement.setAttribute('text-anchor', 'middle');
                } else if (align === 'r') {
                    textElement.setAttribute('x', xPos + line.width);
                    textElement.setAttribute('text-anchor', 'end');
                } else {
                    textElement.setAttribute('x', xPos);
                    textElement.setAttribute('text-anchor', 'start');
                }
                textElement.setAttribute('y', startY + line.startY + (line.runs.length > 0 ? line.runs[0].font.size : 0));

                for (const run of line.runs) {
                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    tspan.setAttribute('font-family', run.font.family);
                    tspan.setAttribute('font-size', `${run.font.size}px`);
                    tspan.setAttribute('font-style', run.font.style);
                    tspan.setAttribute('font-weight', run.font.weight);
                    tspan.setAttribute('fill', run.color);
                    tspan.textContent = run.text;
                    textElement.appendChild(tspan);
                }
                textGroup.appendChild(textElement);
            }
            renderer.currentGroup.appendChild(textGroup);
        }

        async function processShape(shape, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum, finalBg, slideSize) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";

            const nvPr = shape.getElementsByTagNameNS(PML_NS, 'nvPr')[0];
            let phKey = null, phType = null;
            if (nvPr) {
                const placeholder = nvPr.getElementsByTagNameNS(PML_NS, 'ph')[0];
                if (placeholder) {
                    phType = placeholder.getAttribute('type');
                    const phIdx = placeholder.getAttribute('idx');
                    phKey = phIdx ? `idx_${phIdx}` : phType;
                    if (!phType && phIdx) {
                        phType = 'body';
                    }
                }
            }

            const masterPh = masterPlaceholders ? (masterPlaceholders[phKey] || Object.values(masterPlaceholders).find(p => p.type === phType)) : null;
            const layoutPh = layoutPlaceholders ? layoutPlaceholders[phKey] : null;

            const masterShapeProps = masterPh ? masterPh.shapeProps : {};
            const layoutShapeProps = layoutPh ? layoutPh.shapeProps : {};
            const slideShapeProps = parseShapeProperties(shape, slideContext, slideNum);
            let finalFill = slideShapeProps.fill ?? layoutShapeProps.fill ?? masterShapeProps.fill;
            const finalStroke = slideShapeProps.stroke ?? layoutShapeProps.stroke ?? masterShapeProps.stroke;
            const finalEffect = slideShapeProps.effect ?? layoutShapeProps.effect ?? masterShapeProps.effect;

            if (shape.getAttribute('useBgFill') === '1') {
                if (finalBg && finalBg.type === 'color') {
                    finalFill = { type: 'solid', color: finalBg.value };
                } else {
                    finalFill = 'none'; // Or handle image backgrounds if necessary
                }
            }

            const shapeProps = {
                geometry: slideShapeProps.geometry ?? layoutShapeProps.geometry ?? masterShapeProps.geometry,
                fill: finalFill,
                stroke: finalStroke,
                effect: finalEffect,
            };

            const shapeBuilder = new ShapeBuilder(renderer, slideContext, imageMap, masterPlaceholders, layoutPlaceholders, EMU_PER_PIXEL, slideSize);

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            renderer.currentGroup.appendChild(group);
            renderer.currentGroup = group;

            const { pos } = shapeBuilder.build(shape, parentMatrix, shapeProps);

            if (pos) {
                const txBody = shape.getElementsByTagNameNS(PML_NS, 'txBody')[0];
                if (txBody) {
                    const slideBodyPr = parseBodyProperties(txBody);
                    const masterBodyPr = masterPh ? masterPh.bodyPr : {};
                    const layoutBodyPr = layoutPh ? layoutPh.bodyPr : {};
                    const finalBodyPr = { ...masterBodyPr, ...layoutBodyPr, ...slideBodyPr };
                    await processParagraphs(renderer, txBody, { x: 0, y: 0, width: pos.width, height: pos.height }, phKey, phType, slideContext, imageMap, listCounters, defaultTextStyles, masterPlaceholders, layoutPlaceholders, finalBodyPr);
                }
            }

            renderer.currentGroup = group.parentNode;
            return pos;
        }

        function parseGroupShapeProperties(grpSpPrNode, slideContext) {
            if (!grpSpPrNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const properties = { fill: null, ext: null };

            const xfrmNode = grpSpPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
            if (xfrmNode) {
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'chExt')[0];
                if (extNode) {
                    properties.ext = {
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                    };
                }
            }

            let solidFillNode = null;
            let noFillNode = null;
            for (const child of grpSpPrNode.children) {
                if (child.localName === 'solidFill') {
                    solidFillNode = child;
                    break;
                }
                if (child.localName === 'noFill') {
                    noFillNode = child;
                    break;
                }
            }

            if (noFillNode) {
                properties.fill = 'none';
            } else if (solidFillNode) {
                const colorObj = parseColor(solidFillNode);
                if (colorObj) {
                    properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                }
            }
            return properties;
        }

        async function processGroupShape(group, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum, finalBg, slideSize) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const grpSpPrNode = group.getElementsByTagNameNS(PML_NS, 'grpSpPr')[0];
            const cNvPrNode = group.getElementsByTagNameNS(PML_NS, 'cNvPr')[0];
            const groupName = cNvPrNode ? cNvPrNode.getAttribute('name') : 'Unknown Group';

            if (groupName === 'Group 6') {
                console.log(`[GROUP DEBUG] Processing group: "${groupName}"`);
                console.log('[GROUP DEBUG] Parent Matrix:', parentMatrix.m);
            }

            const finalMatrixForChildren = parentMatrix.clone();

            if (grpSpPrNode) {
                const xfrmNode = grpSpPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
                if (xfrmNode) {
                    // Group's position and orientation on the parent canvas
                    const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                    const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                    const x = offNode ? parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL : 0;
                    const y = offNode ? parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL : 0;
                    const w = extNode ? parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL : 0;
                    const h = extNode ? parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL : 0;
                    const rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                    const flipH = xfrmNode.getAttribute('flipH') === '1';
                    const flipV = xfrmNode.getAttribute('flipV') === '1';

                    // Bounding box for the child elements
                    const chOffNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'chOff')[0];
                    const chExtNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'chExt')[0];
                    const chX = chOffNode ? parseInt(chOffNode.getAttribute("x")) / EMU_PER_PIXEL : 0;
                    const chY = chOffNode ? parseInt(chOffNode.getAttribute("y")) / EMU_PER_PIXEL : 0;
                    const chW = chExtNode ? parseInt(chExtNode.getAttribute("cx")) / EMU_PER_PIXEL : 1; // Avoid divide by zero
                    const chH = chExtNode ? parseInt(chExtNode.getAttribute("cy")) / EMU_PER_PIXEL : 1;

                    if (groupName === 'Group 6') {
                        console.table({ x, y, w, h, chX, chY, chW, chH, rot, flipH, flipV });
                    }

                    // Placement Matrix: Transforms the group's frame from local to parent space
                    const placementMatrix = new Matrix();
                    placementMatrix.translate(x, y);
                    placementMatrix.translate(w / 2, h / 2);
                    placementMatrix.rotate(rot * Math.PI / 180);
                    placementMatrix.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                    placementMatrix.translate(-w / 2, -h / 2);

                    // Mapping Matrix: Maps children from their virtual canvas to the group's frame
                    const scaleX = (chW === 0) ? 1 : w / chW;
                    const scaleY = (chH === 0) ? 1 : h / chH;
                    const mappingMatrix = new Matrix();
                    mappingMatrix.scale(scaleX, scaleY);
                    mappingMatrix.translate(-chX, -chY);

                    // Combine them: Final = Parent * Placement * Mapping
                    finalMatrixForChildren.multiply(placementMatrix);
                    finalMatrixForChildren.multiply(mappingMatrix);

                    if (groupName === 'Group 6') {
                        console.log('[GROUP DEBUG] Placement Matrix:', placementMatrix.m);
                        console.log('[GROUP DEBUG] Mapping Matrix:', mappingMatrix.m);
                        console.log('[GROUP DEBUG] Final Matrix for Children:', finalMatrixForChildren.m);
                    }
                }
            }

            for (const element of group.children) {
                const tagName = element.localName;
                if (tagName === 'sp' || tagName === 'cxnSp') {
                    await processShape(element, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, finalMatrixForChildren.clone(), defaultTextStyles, slideNum, finalBg, slideSize);
                } else if (tagName === 'grpSp') {
                    await processGroupShape(element, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, finalMatrixForChildren.clone(), defaultTextStyles, slideNum, finalBg, slideSize);
                } else if (tagName === 'pic') {
                    await processPicture(element, renderer, imageMap, finalMatrixForChildren.clone(), masterPlaceholders, layoutPlaceholders, slideContext, finalBg);
                }
            }
        }

        function getCellBorders(cellNode, tblPrNode, r, c, numRows, numCols, tableStyle, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const borders = {};
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];

            if (tcPrNode) {
                const borderMap = { 'lnL': 'left', 'lnR': 'right', 'lnT': 'top', 'lnB': 'bottom' };
                for (const child of tcPrNode.children) {
                    const side = borderMap[child.localName];
                    if (side) {
                        const lnNode = child;
                        const noFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
                        const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];

                        if (noFillNode) {
                            borders[side] = 'none';
                        } else if (solidFillNode) {
                            const colorObj = parseColor(solidFillNode);
                            const width = parseInt(lnNode.getAttribute('w') || '0') / EMU_PER_PIXEL;
                            if (colorObj && width > 0) {
                                borders[side] = {
                                    color: resolveColor(colorObj, slideContext),
                                    width: width
                                };
                            }
                        }
                    }
                }
            }

             if (!tableStyle) {
                return borders;
            }

            const finalBorders = { ...borders };

            // Base borders from wholeTbl
            const baseBorders = (tableStyle.wholeTbl && tableStyle.wholeTbl.tcStyle && tableStyle.wholeTbl.tcStyle.borders) ? tableStyle.wholeTbl.tcStyle.borders : {};

            const firstRow = tblPrNode.getAttribute('firstRow') === '1';
            const lastRow = tblPrNode.getAttribute('lastRow') === '1';
            const firstCol = tblPrNode.getAttribute('firstCol') === '1';
            const lastCol = tblPrNode.getAttribute('lastCol') === '1';
            const bandRow = tblPrNode.getAttribute('bandRow') === '1';
            const bandCol = tblPrNode.getAttribute('bandCol') === '1';

            const isFirstRow = r === 0;
            const isLastRow = r === numRows - 1;
            const isFirstCol = c === 0;
            const isLastCol = c === numCols - 1;

            const partsToCheck = [];
             if (bandRow) {
                const isDataRow = !(firstRow && isFirstRow) && !(lastRow && isLastRow);
                if (isDataRow) {
                    const dataRowIdx = firstRow ? r - 1 : r;
                    if (dataRowIdx >= 0) {
                        if (dataRowIdx % 2 === 0 && tableStyle.band1H) { partsToCheck.push(tableStyle.band1H); }
                        else if (dataRowIdx % 2 === 1 && tableStyle.band2H) { partsToCheck.push(tableStyle.band2H); }
                    }
                }
            }
             if (bandCol) {
                const isDataCol = !(firstCol && isFirstCol) && !(lastCol && isLastCol);
                 if (isDataCol) {
                    const dataColIdx = firstCol ? c - 1 : c;
                     if (dataColIdx >= 0) {
                        if (dataColIdx % 2 === 0 && tableStyle.band1V) { partsToCheck.push(tableStyle.band1V); }
                        else if (dataColIdx % 2 === 1 && tableStyle.band2V) { partsToCheck.push(tableStyle.band2V); }
                    }
                }
            }
            if (firstRow && isFirstRow && tableStyle.firstRow) { partsToCheck.push(tableStyle.firstRow); }
            if (lastRow && isLastRow && tableStyle.lastRow) { partsToCheck.push(tableStyle.lastRow); }
            if (firstCol && isFirstCol && tableStyle.firstCol) { partsToCheck.push(tableStyle.firstCol); }
            if (lastCol && isLastCol && tableStyle.lastCol) { partsToCheck.push(tableStyle.lastCol); }
            if (firstRow && isFirstRow && firstCol && isFirstCol && tableStyle.nwCell) { partsToCheck.push(tableStyle.nwCell); }
            if (firstRow && isFirstRow && lastCol && isLastCol && tableStyle.neCell) { partsToCheck.push(tableStyle.neCell); }
            if (lastRow && isLastRow && firstCol && isFirstCol && tableStyle.swCell) { partsToCheck.push(tableStyle.swCell); }
            if (lastRow && isLastRow && lastCol && isLastCol && tableStyle.seCell) { partsToCheck.push(tableStyle.seCell); }

            const mergedPartBorders = {};
            for (const part of partsToCheck) {
                if (part && part.tcStyle && part.tcStyle.borders) {
                    Object.assign(mergedPartBorders, part.tcStyle.borders);
                }
            }

            for (const side of ['left', 'right', 'top', 'bottom']) {
                if (finalBorders[side] === undefined) {
                    const borderToApply = mergedPartBorders[side] || baseBorders[side];
                    if (borderToApply) {
                         const color = resolveColor(borderToApply.color, slideContext);
                        if (color) {
                            finalBorders[side] = {
                                width: borderToApply.width,
                                color: color
                            };
                        }
                    }
                }
            }

            return finalBorders;
        }

        function getCellFillColor(cellNode, tblPrNode, r, c, numRows, numCols, tableStyle, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            // Level 1: Direct Formatting (highest precedence)
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];
            if (tcPrNode) {
                let solidFillNode = null;
                for (const child of tcPrNode.children) {
                    if (child.localName === 'solidFill') {
                        solidFillNode = child;
                        break;
                    }
                }
                if (solidFillNode) {
                    const colorObj = parseColor(solidFillNode);
                    if (colorObj) {
                        return resolveColor(colorObj, slideContext);
                    }
                }
            }

            if (!tableStyle) {
                return null;
            }

            // Level 2 & 3: Table Styles (layered)
            let finalFill = null;

            // Base fill from wholeTbl
            if (tableStyle.wholeTbl && tableStyle.wholeTbl.tcStyle && tableStyle.wholeTbl.tcStyle.fill) {
                finalFill = tableStyle.wholeTbl.tcStyle.fill;
            }

            const firstRow = tblPrNode.getAttribute('firstRow') === '1';
            const lastRow = tblPrNode.getAttribute('lastRow') === '1';
            const firstCol = tblPrNode.getAttribute('firstCol') === '1';
            const lastCol = tblPrNode.getAttribute('lastCol') === '1';
            const bandRow = tblPrNode.getAttribute('bandRow') === '1';
            const bandCol = tblPrNode.getAttribute('bandCol') === '1';

            const isFirstRow = r === 0;
            const isLastRow = r === numRows - 1;
            const isFirstCol = c === 0;
            const isLastCol = c === numCols - 1;

            // Layer styles in increasing order of precedence
            const partsToCheck = [];
            if (bandRow) {
                const isDataRow = !(firstRow && isFirstRow) && !(lastRow && isLastRow);
                if (isDataRow) {
                    const dataRowIdx = firstRow ? r - 1 : r;
                    if (dataRowIdx >= 0) {
                        if (dataRowIdx % 2 === 0 && tableStyle.band1H) { partsToCheck.push(tableStyle.band1H); }
                        else if (dataRowIdx % 2 === 1 && tableStyle.band2H) { partsToCheck.push(tableStyle.band2H); }
                    }
                }
            }
             if (bandCol) {
                const isDataCol = !(firstCol && isFirstCol) && !(lastCol && isLastCol);
                 if (isDataCol) {
                    const dataColIdx = firstCol ? c - 1 : c;
                     if (dataColIdx >= 0) {
                        if (dataColIdx % 2 === 0 && tableStyle.band1V) { partsToCheck.push(tableStyle.band1V); }
                        else if (dataColIdx % 2 === 1 && tableStyle.band2V) { partsToCheck.push(tableStyle.band2V); }
                    }
                }
            }
            if (firstRow && isFirstRow && tableStyle.firstRow) { partsToCheck.push(tableStyle.firstRow); }
            if (lastRow && isLastRow && tableStyle.lastRow) { partsToCheck.push(tableStyle.lastRow); }
            if (firstCol && isFirstCol && tableStyle.firstCol) { partsToCheck.push(tableStyle.firstCol); }
            if (lastCol && isLastCol && tableStyle.lastCol) { partsToCheck.push(tableStyle.lastCol); }
            if (firstRow && isFirstRow && firstCol && isFirstCol && tableStyle.nwCell) { partsToCheck.push(tableStyle.nwCell); }
            if (firstRow && isFirstRow && lastCol && isLastCol && tableStyle.neCell) { partsToCheck.push(tableStyle.neCell); }
            if (lastRow && isLastRow && firstCol && isFirstCol && tableStyle.swCell) { partsToCheck.push(tableStyle.swCell); }
            if (lastRow && isLastRow && lastCol && isLastCol && tableStyle.seCell) { partsToCheck.push(tableStyle.seCell); }

            for (const part of partsToCheck) {
                if (part && part.tcStyle && part.tcStyle.fill) {
                    finalFill = part.tcStyle.fill;
                }
            }

            return finalFill ? resolveColor(finalFill, slideContext) : null;
        }

        async function processTable(graphicFrame, renderer, slideContext, parentMatrix) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";

            const xfrmNode = graphicFrame.getElementsByTagNameNS(PML_NS, 'xfrm')[0];
            let pos = { x: 0, y: 0, width: 0, height: 0 };
            const localMatrix = new Matrix();

            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    const x = parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL;
                    const y = parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL;
                    const w = parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL;
                    const h = parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL;
                    const rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                    const flipH = xfrmNode.getAttribute('flipH') === '1';
                    const flipV = xfrmNode.getAttribute('flipV') === '1';

                    pos = { x: 0, y: 0, width: w, height: h }; // Position is now relative to the container

                    localMatrix.translate(x, y);
                    localMatrix.translate(w / 2, h / 2);
                    localMatrix.rotate(rot * Math.PI / 180);
                    localMatrix.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                    localMatrix.translate(-w / 2, -h / 2);
                }
            }

            const finalMatrix = parentMatrix.clone().multiply(localMatrix);
            renderer.setTransform(finalMatrix);

            const tblNode = graphicFrame.getElementsByTagNameNS(DML_NS, 'tbl')[0];
            if (!tblNode) return {
                width: pos.width,
                height: pos.height
            };

            const tblPrNode = tblNode.getElementsByTagNameNS(DML_NS, 'tblPr')[0];

            const tableStyleIdNode = tblPrNode ? tblPrNode.getElementsByTagNameNS(DML_NS, 'tableStyleId')[0] : null;
            let styleId = tableStyleIdNode ? tableStyleIdNode.textContent : null;

            if (!styleId && slideContext.defaultTableStyleId) {
                styleId = `{${slideContext.defaultTableStyleId}}`;
            }

            const tableStyle = styleId ? slideContext.tableStyles[styleId] : null;

            // 2. Parse grid and column widths
            const tblGridNode = tblNode.getElementsByTagNameNS(DML_NS, 'tblGrid')[0];
            const gridColNodes = tblGridNode ? tblGridNode.getElementsByTagNameNS(DML_NS, 'gridCol') : [];
            const colWidths = Array.from(gridColNodes).map(node => parseInt(node.getAttribute('w')) / EMU_PER_PIXEL);

            // 3. Iterate through rows and cells to build a renderable grid
            const rowNodes = Array.from(tblNode.getElementsByTagNameNS(DML_NS, 'tr'));
            const numRows = rowNodes.length;
            const numCols = colWidths.length;
            if (numRows === 0 || numCols === 0) return {
                width: pos.width,
                height: pos.height
            };

            const renderedGrid = Array(numRows).fill(0).map(() => Array(numCols).fill(false));

            for (let r = 0; r < numRows; r++) {
                const cellNodes = Array.from(rowNodes[r].getElementsByTagNameNS(DML_NS, 'tc'));

                for (let c = 0; c < numCols; c++) {
                    if (renderedGrid[r][c]) {
                        continue; // Already handled by a previous rowspan
                    }

                    const cellNode = cellNodes[c];
                    if (!cellNode) continue;

                    const hMerge = cellNode.getAttribute('hMerge') === '1';
                    const vMerge = cellNode.getAttribute('vMerge') === '1';

                    if (hMerge || vMerge) {
                        continue; // Handled by the primary cell of the merge
                    }

                    const gridSpan = parseInt(cellNode.getAttribute('gridSpan') || '1');
                    const rowSpan = parseInt(cellNode.getAttribute('rowSpan') || '1');

                    // Calculate cell dimensions based on spans
                    let cellWidth = 0;
                    for (let i = 0; i < gridSpan; i++) {
                        if (c + i < numCols) cellWidth += colWidths[c + i];
                    }

                    let cellHeight = 0;
                    for (let i = 0; i < rowSpan; i++) {
                        if (r + i < numRows) {
                            cellHeight += parseInt(rowNodes[r + i].getAttribute('h')) / EMU_PER_PIXEL;
                        }
                    }

                    // Calculate cell position
                    let cellX = pos.x;
                    for (let i = 0; i < c; i++) {
                        cellX += colWidths[i];
                    }

                    let cellY = pos.y;
                    for (let i = 0; i < r; i++) {
                        cellY += parseInt(rowNodes[i].getAttribute('h')) / EMU_PER_PIXEL;
                    }

                    // Mark grid cells covered by this span as rendered
                    for (let i = 0; i < rowSpan; i++) {
                        for (let j = 0; j < gridSpan; j++) {
                            if (r + i < numRows && c + j < numCols) {
                                renderedGrid[r + i][c + j] = true;
                            }
                        }
                    }

                    // Step 4: Get cell styling
                    const fillColor = getCellFillColor(cellNode, tblPrNode, r, c, numRows, numCols, tableStyle, slideContext);

                    renderer.drawRect(cellX, cellY, cellWidth, cellHeight, { fill: fillColor || 'transparent' });

                    // Draw borders using a strategy to avoid double-drawing
                    const borders = getCellBorders(cellNode, tblPrNode, r, c, numRows, numCols, tableStyle, slideContext);
                    const borderDefs = {
                        top: { p: [cellX, cellY, cellX + cellWidth, cellY], draw: (r === 0) },
                        right: { p: [cellX + cellWidth, cellY, cellX + cellWidth, cellY + cellHeight], draw: true },
                        bottom: { p: [cellX + cellWidth, cellY + cellHeight, cellX, cellY + cellHeight], draw: true },
                        left: { p: [cellX, cellY + cellHeight, cellX, cellY], draw: (c === 0) },
                    };

                    for (const side in borderDefs) {
                        const borderStyle = borders[side];
                        if (borderStyle && borderStyle !== 'none' && borderDefs[side].draw) {
                            renderer.drawLine(borderDefs[side].p[0], borderDefs[side].p[1], borderDefs[side].p[2], borderDefs[side].p[3], { stroke: borderStyle });
                        }
                    }

                    // Render text content
                    await processCellText(cellNode, renderer, cellX, cellY, cellWidth, cellHeight, slideContext);
                }
            }

            return {
                width: pos.width,
                height: pos.height
            };
        }

        async function processCellText(cellNode, renderer, cellX, cellY, cellWidth, cellHeight, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const txBodyNode = cellNode.getElementsByTagNameNS(DML_NS, 'txBody')[0];
            if (!txBodyNode) return;

            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];
            const bodyPrFromTxBody = parseBodyProperties(txBodyNode);

            // Default OOXML table cell margins in EMUs
            const DEFAULT_L_R_MARGIN_EMU = 91440;
            const DEFAULT_T_B_MARGIN_EMU = 45720;

            const bodyPrFromTcPr = {
                // Apply defaults first
                lIns: DEFAULT_L_R_MARGIN_EMU / EMU_PER_PIXEL,
                rIns: DEFAULT_L_R_MARGIN_EMU / EMU_PER_PIXEL,
                tIns: DEFAULT_T_B_MARGIN_EMU / EMU_PER_PIXEL,
                bIns: DEFAULT_T_B_MARGIN_EMU / EMU_PER_PIXEL,
            };

            if (tcPrNode) {
                const anchor = tcPrNode.getAttribute('anchor');
                if (anchor) bodyPrFromTcPr.anchor = anchor;

                const marL = tcPrNode.getAttribute('marL');
                if (marL) bodyPrFromTcPr.lIns = parseInt(marL) / EMU_PER_PIXEL;

                const marT = tcPrNode.getAttribute('marT');
                if (marT) bodyPrFromTcPr.tIns = parseInt(marT) / EMU_PER_PIXEL;

                const marR = tcPrNode.getAttribute('marR');
                if (marR) bodyPrFromTcPr.rIns = parseInt(marR) / EMU_PER_PIXEL;

                const marB = tcPrNode.getAttribute('marB');
                if (marB) bodyPrFromTcPr.bIns = parseInt(marB) / EMU_PER_PIXEL;
            }

            const bodyPr = { ...bodyPrFromTxBody, ...bodyPrFromTcPr };

            const pos = {
                x: cellX,
                y: cellY,
                width: cellWidth,
                height: cellHeight
            };

            const clipId = `clip-${Math.random().toString(36).substr(2, 9)}`;
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', clipId);
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', cellX);
            rect.setAttribute('y', cellY);
            rect.setAttribute('width', cellWidth);
            rect.setAttribute('height', cellHeight);
            clipPath.appendChild(rect);
            renderer.defs.appendChild(clipPath);

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('clip-path', `url(#${clipId})`);
            renderer.currentGroup.appendChild(group);
            const originalGroup = renderer.currentGroup;
            renderer.currentGroup = group;

            const listCounters = {};
            const defaultTextStyles = { title: {}, body: {}, other: {} };
            const masterPlaceholders = {};
            const layoutPlaceholders = {};

            await processParagraphs(renderer, txBodyNode, pos, null, 'body', slideContext, {}, listCounters, defaultTextStyles, masterPlaceholders, layoutPlaceholders, bodyPr);

            renderer.currentGroup = originalGroup;
        }

        function buildPathStringFromGeom(geometry, pos) {
            if (!geometry || !pos) return null;

            if (geometry.type === 'custom' && geometry.path) {
                const pathData = geometry.path;
                const scaleX = pathData.w === 0 ? 1 : pos.width / pathData.w;
                const scaleY = pathData.h === 0 ? 1 : pos.height / pathData.h;

                let pathString = '';
                pathData.commands.forEach(command => {
                    switch (command.cmd) {
                        case 'moveTo': {
                            const p = command.points[0];
                            pathString += `M ${p.x * scaleX} ${p.y * scaleY} `;
                            break;
                        }
                        case 'lnTo': {
                            const p = command.points[0];
                            pathString += `L ${p.x * scaleX} ${p.y * scaleY} `;
                            break;
                        }
                        case 'cubicBezTo': {
                            const p1 = command.points[0];
                            const p2 = command.points[1];
                            const p3 = command.points[2];
                            pathString += `C ${p1.x * scaleX} ${p1.y * scaleY} ${p2.x * scaleX} ${p2.y * scaleY} ${p3.x * scaleX} ${p3.y * scaleY} `;
                            break;
                        }
                        case 'quadBezTo': {
                            const p1 = command.points[0];
                            const p2 = command.points[1];
                            pathString += `Q ${p1.x * scaleX} ${p1.y * scaleY} ${p2.x * scaleX} ${p2.y * scaleY} `;
                            break;
                        }
                        case 'close': {
                            pathString += 'Z ';
                            break;
                        }
                    }
                });
                return pathString;
            }

            return null;
        }

        function parseSourceRectangle(blipFillNode) {
            if (!blipFillNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const srcRectNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'srcRect')[0];
            if (!srcRectNode) return null;

            return {
                l: parseInt(srcRectNode.getAttribute('l') || '0') / 100000,
                r: parseInt(srcRectNode.getAttribute('r') || '0') / 100000,
                t: parseInt(srcRectNode.getAttribute('t') || '0') / 100000,
                b: parseInt(srcRectNode.getAttribute('b') || '0') / 100000,
            };
        }

        async function processPicture(picNode, renderer, imageMap, parentMatrix, masterPlaceholders, layoutPlaceholders, slideContext, finalBg) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            let localMatrix = new Matrix();
            let pos;

            const nvPicPrNode = picNode.getElementsByTagNameNS(PML_NS, 'nvPicPr')[0];
            const nvPrNode = nvPicPrNode ? nvPicPrNode.getElementsByTagNameNS(PML_NS, 'nvPr')[0] : null;
            const phNode = nvPrNode ? nvPrNode.getElementsByTagNameNS(PML_NS, 'ph')[0] : null;

            const spPrNode = picNode.getElementsByTagNameNS(PML_NS, 'spPr')[0];
            const xfrmNode = spPrNode ? spPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0] : null;

            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    const x = parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL;
                    const y = parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL;
                    const w = parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL;
                    const h = parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL;
                    const rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                    const flipH = xfrmNode.getAttribute('flipH') === '1';
                    const flipV = xfrmNode.getAttribute('flipV') === '1';

                    pos = { width: w, height: h };

                    localMatrix.translate(x, y);
                    localMatrix.translate(w / 2, h / 2);
                    localMatrix.rotate(rot * Math.PI / 180);
                    localMatrix.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                    localMatrix.translate(-w / 2, -h / 2);
                }
            } else if (phNode) {
                const phType = phNode.getAttribute('type');
                const phIdx = phNode.getAttribute('idx');
                const phKey = phIdx ? `idx_${phIdx}` : phType;

                const layoutPh = layoutPlaceholders ? layoutPlaceholders[phKey] : null;
                const masterPh = masterPlaceholders ? masterPlaceholders[phKey] : null;
                const placeholder = layoutPh || masterPh;

                if (placeholder && placeholder.pos) {
                    pos = { ...placeholder.pos };
                    localMatrix.translate(pos.x, pos.y);
                }
            }

            if (!pos) return { width: 0, height: 0 };

            const finalMatrix = parentMatrix.clone().multiply(localMatrix);

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('transform', `matrix(${finalMatrix.m.join(' ')})`);
            renderer.currentGroup.appendChild(group);

            const originalGroup = renderer.currentGroup;
            renderer.currentGroup = group;

            let placeholderProps = null;
            if (phNode) {
                const phType = phNode.getAttribute('type');
                const phIdx = phNode.getAttribute('idx');
                const phKey = phIdx ? `idx_${phIdx}` : phType;
                const layoutPh = layoutPlaceholders ? layoutPlaceholders[phKey] : null;
                const masterPh = masterPlaceholders ? masterPlaceholders[phKey] : null;

                const masterShapeProps = masterPh ? masterPh.shapeProps : {};
                const layoutShapeProps = layoutPh ? layoutPh.shapeProps : {};

                placeholderProps = { ...masterShapeProps, ...layoutShapeProps };
            }

            const pathString = (placeholderProps && placeholderProps.geometry)
                ? buildPathStringFromGeom(placeholderProps.geometry, pos)
                : null;

            // 1. Draw Placeholder Fill
            if (placeholderProps && placeholderProps.fill && placeholderProps.fill !== 'none' && placeholderProps.fill.type === 'solid') {
                if (pathString) {
                    renderer.drawPath(pathString, { fill: placeholderProps.fill.color });
                } else {
                    renderer.drawRect(0, 0, pos.width, pos.height, { fill: placeholderProps.fill.color });
                }
            }
             // 2. Draw Image
            const blipFillNode = picNode.getElementsByTagNameNS(PML_NS, 'blipFill')[0];
            if (blipFillNode) {
                const blipNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                const relId = blipNode ? blipNode.getAttribute('r:embed') : null;
                if (relId && imageMap[relId]) {
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', imageMap[relId]);

                    const srcRect = parseSourceRectangle(blipFillNode);
                    if (srcRect) {
                        const img = await createImage(imageMap[relId]);
                        const naturalWidth = img.width;
                        const naturalHeight = img.height;

                        const cropLeft = naturalWidth * srcRect.l;
                        const cropTop = naturalHeight * srcRect.t;
                        const cropWidth = naturalWidth * (1 - srcRect.l - srcRect.r);
                        const cropHeight = naturalHeight * (1 - srcRect.t - srcRect.b);

                        image.setAttribute('viewBox', `${cropLeft} ${cropTop} ${cropWidth} ${cropHeight}`);
                        image.setAttribute('preserveAspectRatio', 'none');
                    }

                    image.setAttribute('x', 0);
                    image.setAttribute('y', 0);
                    image.setAttribute('width', pos.width);
                    image.setAttribute('height', pos.height);

                    if (pathString) {
                        const clipId = `clip-${Math.random().toString(36).substr(2, 9)}`;
                        const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                        clipPath.setAttribute('id', clipId);
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', pathString);
                        clipPath.appendChild(path);
                        renderer.defs.appendChild(clipPath);
                        image.setAttribute('clip-path', `url(#${clipId})`);
                    }

                    group.appendChild(image);
                }
            }

            // 3. Draw Placeholder Stroke
            if (placeholderProps && placeholderProps.stroke) {
                if (pathString) {
                    renderer.drawPath(pathString, { stroke: placeholderProps.stroke });
                } else {
                    renderer.drawRect(0, 0, pos.width, pos.height, { stroke: placeholderProps.stroke });
                }
            }

            renderer.currentGroup = originalGroup;

            return { width: pos.width, height: pos.height };
        }

        async function processShapeTree(elements, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, slideRels, entriesMap, parentMatrix, finalBg, slideSize) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            for (const element of elements) {
                const tagName = element.localName;
                if (tagName === 'sp' || tagName === 'cxnSp') {
                    await processShape(element, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum, finalBg, slideSize);
                } else if (tagName === 'grpSp') {
                    await processGroupShape(element, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum, finalBg, slideSize);
                } else if (tagName === 'graphicFrame') {
                    const graphicData = element.getElementsByTagNameNS(DML_NS, 'graphicData')[0];
                    if (graphicData && graphicData.getAttribute('uri') === 'http://schemas.openxmlformats.org/drawingml/2006/table') {
                        await processTable(element, renderer, slideContext, parentMatrix.clone());
                    } else if (graphicData && graphicData.getAttribute('uri') === 'http://schemas.openxmlformats.org/drawingml/2006/chart') {
                        const chartRelId = graphicData.getElementsByTagNameNS("http://schemas.openxmlformats.org/drawingml/2006/chart", "chart")[0].getAttribute("r:id");
                        if (chartRelId && slideRels && slideRels[chartRelId]) {
                            const chartPath = resolvePath('ppt/slides', slideRels[chartRelId].target);
                            const chartXml = await getNormalizedXmlString(entriesMap, chartPath);
                            if (chartXml) {
                                const chartData = parseChart(chartXml);
                                await renderChart(element, renderer, chartData, parentMatrix.clone());
                            }
                        }
                    }
                } else if (tagName === 'pic') {
                    await processPicture(element, renderer, imageMap, parentMatrix, masterPlaceholders, layoutPlaceholders, slideContext, finalBg);
                }
            }
        }

        async function renderSlide( slideXml, slideContainer, masterPlaceholders, layoutPlaceholders, slideNum, slideSize, defaultTextStyles, imageMap, slideContext, finalBg, showMasterShapes, masterStaticShapes, layoutStaticShapes, slideRels, entriesMap ) {
            const xmlDoc = parseXmlString(slideXml, `slide number ${slideNum}`);
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const SVG_NS = "http://www.w3.org/2000/svg";

            const listCounters = {};
            const svg = document.createElementNS(SVG_NS, 'svg');
            svg.setAttribute('viewBox', `0 0 ${slideSize.width} ${slideSize.height}`);
            svg.style.width = '100%';
            svg.style.height = '100%';
            slideContainer.appendChild(svg);

            const renderer = new SvgRenderer(svg, slideContext);

            const defs = document.createElementNS(SVG_NS, 'defs');
            svg.appendChild(defs);
            renderer.defs = defs;

            if (finalBg) {
                if (finalBg.type === 'color') {
                    const bgRect = document.createElementNS(SVG_NS, 'rect');
                    bgRect.setAttribute('width', '100%');
                    bgRect.setAttribute('height', '100%');
                    bgRect.setAttribute('fill', finalBg.value);
                    svg.insertBefore(bgRect, svg.firstChild);
                } else if (finalBg.type === 'image' && finalBg.relId && imageMap[finalBg.relId]) {
                    const bgImage = document.createElementNS(SVG_NS, 'image');
                    bgImage.setAttribute('href', imageMap[finalBg.relId]);
                    bgImage.setAttribute('width', slideSize.width);
                    bgImage.setAttribute('height', slideSize.height);
                    bgImage.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    svg.insertBefore(bgImage, svg.firstChild);
                }
            }

            const initialMatrix = new Matrix();
            if (showMasterShapes) {
                if (masterStaticShapes) {
                    await processShapeTree(masterStaticShapes, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, null, entriesMap, initialMatrix.clone(), finalBg, slideSize);
                }
                 if (layoutStaticShapes) {
                    await processShapeTree(layoutStaticShapes, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, null, entriesMap, initialMatrix.clone(), finalBg, slideSize);
                }
            }

            const spTreeNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'spTree')[0];
            if (spTreeNode) {
                await processShapeTree(spTreeNode.children, renderer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, slideRels, entriesMap, initialMatrix.clone(), finalBg, slideSize);
            }
             // Since SVG is scalable, we don't need the resize observer. The viewBox handles it.
        }

        function parseChart(chartXml) {
            const xmlDoc = parseXmlString(chartXml, "chart");
            const C_NS = "http://schemas.openxmlformats.org/drawingml/2006/chart";

            const chartData = {
                type: null,
                title: null,
                labels: [],
                datasets: []
            };

            const titleNode = xmlDoc.getElementsByTagNameNS(C_NS, 'title')[0];
            if (titleNode) {
                chartData.title = titleNode.textContent.trim();
            }

            const plotAreaNode = xmlDoc.getElementsByTagNameNS(C_NS, 'plotArea')[0];
            if (!plotAreaNode) return null;

            const chartTypeMap = {
                'barChart': 'bar',
                'lineChart': 'line',
                'pieChart': 'pie',
                // TODO: Add other chart types
            };

            let chartTypeNode;
            for (const type in chartTypeMap) {
                chartTypeNode = plotAreaNode.getElementsByTagNameNS(C_NS, type)[0];
                if (chartTypeNode) {
                    chartData.type = chartTypeMap[type];
                    break;
                }
            }

            if (!chartTypeNode) return null;

            const serNodes = chartTypeNode.getElementsByTagNameNS(C_NS, 'ser');
            for (const serNode of serNodes) {
                const dataset = {
                    label: '',
                    data: []
                };

                const txValNode = serNode.getElementsByTagNameNS(C_NS, 'tx')[0]?.getElementsByTagNameNS(C_NS, 'v')[0];
                if (txValNode) {
                    dataset.label = txValNode.textContent.trim();
                }

                const catNode = serNode.getElementsByTagNameNS(C_NS, 'cat')[0];
                if (catNode) {
                    const strRefNode = catNode.getElementsByTagNameNS(C_NS, 'strRef')[0];
                    if (strRefNode) {
                        const ptNodes = strRefNode.getElementsByTagNameNS(C_NS, 'pt');
                        chartData.labels = Array.from(ptNodes).map(pt => pt.textContent.trim());
                    }
                }

                const valNode = serNode.getElementsByTagNameNS(C_NS, 'val')[0];
                if (valNode) {
                    const numRefNode = valNode.getElementsByTagNameNS(C_NS, 'numRef')[0];
                    if (numRefNode) {
                        const ptNodes = numRefNode.getElementsByTagNameNS(C_NS, 'pt');
                        dataset.data = Array.from(ptNodes).map(pt => parseFloat(pt.textContent.trim()));
                    }
                }

                chartData.datasets.push(dataset);
            }

            return chartData;
        }

        async function renderChart(graphicFrame, renderer, chartData) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const xfrmNode = graphicFrame.getElementsByTagNameNS(PML_NS, 'xfrm')[0];
            if (!xfrmNode) return;

            const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
            const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
            if (!offNode || !extNode) return;

            const pos = {
                x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
            };

            const chartContainer = document.createElement('div');
            chartContainer.style.position = 'absolute';
            chartContainer.style.left = `${pos.x}px`;
            chartContainer.style.top = `${pos.y}px`;
            chartContainer.style.width = `${pos.width}px`;
            chartContainer.style.height = `${pos.height}px`;

            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);

            renderer.svg.parentElement.appendChild(chartContainer);


            const ctx = canvas.getContext('2d');
            new Chart(ctx, {
                type: chartData.type,
                data: {
                    labels: chartData.labels,
                    datasets: chartData.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: !!chartData.title,
                            text: chartData.title
                        }
                    }
                }
            });
        }
    </script>
</body>

</html>
