<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Native PPTX Parser - Step 4</title>
    <style>
        /* General Body Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #f9fafb;
            color: #1f2937;
            margin: 0;
            padding: 0;
            line-height: 1.5;
        }

        /* Container and Layout */
        .container {
            width: 100%;
            max-width: 56rem;
            /* 896px */
            margin-left: auto;
            margin-right: auto;
            padding: 2rem 1rem;
        }

        /* Header and Typography */
        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2.25rem;
            /* 36px */
            font-weight: 700;
            color: #111827;
        }

        header p {
            margin-top: 0.5rem;
            font-size: 1.125rem;
            /* 18px */
            color: #4b5563;
        }

        /* Card-like Sections */
        .card {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .card h2 {
            font-size: 1.5rem;
            /* 24px */
            font-weight: 600;
            margin-bottom: 1rem;
        }

        /* File Upload Area */
        .file-upload-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 12rem;
            /* 192px */
            border: 2px dashed #d1d5db;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #f9fafb;
            transition: background-color 0.2s ease-in-out;
        }

        .file-upload-label:hover {
            background-color: #f3f4f6;
        }

        #pptx-file {
            display: none;
        }

        #file-info {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.875rem;
            /* 14px */
            color: #6b7280;
        }

        /* --- Slide Viewer & Debug Styling --- */
        .slide-viewer {
            width: 100%;
            height: auto;
            border: 1px solid #e5e7eb;
            background-color: #fff;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin: 2rem auto;
            position: relative;
        }

        .slide-viewer svg {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
            /* For visualization */
        }

        #debug-output {
            margin-top: 1.5rem;
            background-color: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: "SF Mono", "Fira Code", "Fira Mono", "Roboto Mono", monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #debug-output h3 {
            margin-top: 0;
            color: #9ca3af;
            font-weight: 500;
        }

        /* Loading Spinner */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>Native PPTX Parser</h1>
            <p><strong>Step 4:</strong> Integrating Slide Layouts for correct positioning.</p>
        </header>

        <div>
            <!-- File Upload Section -->
            <div class="card">
                <h2>1. Upload Presentation</h2>
                <div>
                    <label for="pptx-file" class="file-upload-label">
                        <!-- SVG icon for upload -->
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                            </path>
                        </svg>
                        <p><span>Click to upload</span> or drag and drop</p>
                        <p>PPTX file</p>
                        <input id="pptx-file" type="file" accept=".pptx" />
                    </label>
                </div>
                <div id="file-info"></div>
            </div>

            <!-- Slide Render Section -->
            <div id="output-container" style="display: none;">
                <div id="loading-indicator" style="text-align: center; padding: 2rem;">
                    <!-- SVG spinner -->
                    <svg aria-hidden="true"
                        style="display: inline; width: 2rem; height: 2rem; margin-right: 0.5rem; color: #e5e7eb; animation: spin 1s linear infinite;"
                        viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
                            fill="currentColor" />
                        <path
                            d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
                            fill="#4f46e5" />
                    </svg>
                    <p>Rendering slides...</p>
                </div>
                <div id="slide-viewer-container"></div>
                <div id="debug-output" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Main application script -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.2.0/dist/chart.umd.js"></script>
    <script type="module">
        import {
            BlobReader,
            BlobWriter,
            TextReader,
            TextWriter,
            ZipReader,
            ZipWriter,
        } from "https://deno.land/x/zipjs/index.js";
        import Konva from 'https://cdn.jsdelivr.net/npm/konva@9.3.6/+esm';

        const EMU_PER_PIXEL = 9525; // Standard conversion for 96 DPI
        const LINE_HEIGHT = 24; // A default line height in pixels for SVG text
        const INDENTATION_AMOUNT = 30; // Pixels per indentation level
        const BULLET_OFFSET = 20; // Space between bullet and text

        const fileInput = document.getElementById( 'pptx-file' );
        const fileInfo = document.getElementById( 'file-info' );
        const outputContainer = document.getElementById( 'output-container' );
        let activeCharts = [];
        const slideViewerContainer = document.getElementById( 'slide-viewer-container' );
        const loadingIndicator = document.getElementById( 'loading-indicator' );
        const debugOutput = document.getElementById( 'debug-output' );

        function resolvePath(baseDir, target) {
            // Normalize backslashes to forward slashes for cross-platform compatibility.
            const normalizedTarget = target.replace(/\\/g, '/');

            // If target is an absolute path (starts with '/'), it's relative to the zip root.
            if (normalizedTarget.startsWith('/')) {
                // Just remove the leading slash and return.
                return normalizedTarget.substring(1);
            }
            // Otherwise, resolve it relative to the baseDir.
            const path = baseDir + '/' + normalizedTarget;
            const parts = path.split('/');
            const resolved = [];
            for (const part of parts) {
                if (part === '..') {
                    resolved.pop();
                } else if (part !== '.' && part !== '') {
                    resolved.push(part);
                }
            }
            return resolved.join('/');
        }
        function parseXmlString(xmlString, identifier) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            const errorNode = xmlDoc.querySelector("parsererror");
            if (errorNode) {
                console.error(`XML Parsing Error in ${identifier}:`, errorNode.innerHTML);
                console.log(`Problematic XML for ${identifier}:`, xmlString);
            }
            return xmlDoc;
        }

        async function getNormalizedXmlString(entriesMap, path) {
            const entry = entriesMap.get(path);
            if (!entry) return null;

            const writer = new TextWriter();
            let xmlString = await entry.getData(writer);

            // Strip BOM if present, as it can interfere with XML parsing on some platforms.
            if (xmlString.charCodeAt(0) === 0xFEFF) {
                xmlString = xmlString.substring(1);
            }

            // Normalize line endings to prevent cross-platform parsing issues.
            return xmlString.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        }

        fileInput.addEventListener( 'change', async ( event ) => {
            const file = event.target.files[ 0 ];
            if ( !file ) return;

            fileInfo.textContent = `File selected: ${ file.name }`;
            outputContainer.style.display = 'block';
            slideViewerContainer.innerHTML = '';
            debugOutput.style.display = 'none';
            loadingIndicator.style.display = 'block';
            debugOutput.innerHTML = '';

            const zipReader = new ZipReader(new BlobReader(file));
            try {
                const entries = await zipReader.getEntries();
                const entriesMap = new Map(entries.map(entry => [entry.filename, entry]));

                const presRels = await getRelationships( entriesMap, "ppt/_rels/presentation.xml.rels" );
                const sortedPresRels = Object.values(presRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));

                let theme = null;
                const themeRel = sortedPresRels.find(rel => rel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme');
                if (themeRel) {
                    const themePath = resolvePath('ppt', themeRel.target);
                    const themeXml = await getNormalizedXmlString(entriesMap, themePath);
                    if (themeXml) theme = parseTheme(themeXml);
                }

                let tableStyles = {};
                const tableStylesRel = sortedPresRels.find(rel => rel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles');
                if (tableStylesRel) {
                    const tableStylesPath = resolvePath('ppt', tableStylesRel.target);
                    const tableStylesXml = await getNormalizedXmlString(entriesMap, tableStylesPath);
                    if (tableStylesXml) tableStyles = parseTableStyles(tableStylesXml);
                }

                const presentationXml = await getNormalizedXmlString(entriesMap, "ppt/presentation.xml");
                const slideIds = getSlideOrder( presentationXml );

                const slideSize = getSlideSize( presentationXml );

                if ( slideIds.length === 0 ) {
                    fileInfo.textContent = "No slides found in the presentation.";
                    return;
                }

                let allSlidesDebugText = '<h3>Raw Parsed Content:</h3>';
                let totalElementsFound = 0;

                for ( let i = 0; i < slideIds.length; i++ ) {
                    const slideId = slideIds[ i ];
                    const slideRel = presRels[ slideId ];
                    if ( !slideRel ) continue;

                    const slidePath = resolvePath( 'ppt', slideRel.target );
                    const slideRelsPath = `ppt/slides/_rels/${ slidePath.split( '/' ).pop() }.rels`;
                    const slideRels = await getRelationships( entriesMap, slideRelsPath );
                    const sortedSlideRels = Object.values(slideRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));

                    const imageMap = {};
                    for (const rel of sortedSlideRels) {
                        if (rel.type.endsWith('/image')) {
                            const imagePath = resolvePath('ppt/slides', rel.target);
                            const imageEntry = entriesMap.get(imagePath);
                            if (imageEntry) {
                                const writer = new BlobWriter();
                                const imageBlob = await imageEntry.getData(writer);
                                const reader = new FileReader();
                                const imageData = await new Promise((resolve, reject) => {
                                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                                imageMap[rel.id] = `data:image/png;base64,${imageData}`;
                            }
                        }
                    }

                    const slideContext = {
                        theme: theme,
                        colorMap: {},
                        tableStyles: tableStyles,
                    };

                    const layoutRel = sortedSlideRels.find( r => r.type.endsWith( '/slideLayout' ) );

                    let finalPlaceholders = {};
                    let defaultTextStyles = {};
                    let masterXml, layoutXml;

                    let masterStaticShapes = [], layoutStaticShapes = [];
                    if ( layoutRel ) {
                        const layoutPath = resolvePath('ppt/slides', layoutRel.target);
                        const layoutRelsPath = `ppt/slideLayouts/_rels/${ layoutPath.split( '/' ).pop() }.rels`;
                        const layoutRels = await getRelationships( entriesMap, layoutRelsPath );
                        const sortedLayoutRels = Object.values(layoutRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));
                        const masterRel = sortedLayoutRels.find( r => r.type.endsWith( '/slideMaster' ) );

                        let masterData;
                        if ( masterRel ) {
                            const masterPath = resolvePath('ppt/slideLayouts', masterRel.target);
                            masterXml = await getNormalizedXmlString(entriesMap, masterPath);
                            if (masterXml) {
                                masterData = parseMasterOrLayout( masterXml );
                            }
                            finalPlaceholders = masterData.placeholders;
                            masterStaticShapes = masterData.staticShapes;
                            defaultTextStyles = masterData.defaultTextStyles;
                            slideContext.colorMap = masterData.colorMap;
                        }

                        let layoutData;
                        layoutXml = await getNormalizedXmlString(entriesMap, layoutPath);
                        if (layoutXml) {
                            layoutData = parseMasterOrLayout( layoutXml, true );
                        }
                        finalPlaceholders = { ...finalPlaceholders, ...layoutData.placeholders };
                        layoutStaticShapes = layoutData.staticShapes;
                        if (layoutData.colorMapOverride) {
                            slideContext.colorMap = { ...slideContext.colorMap, ...layoutData.colorMapOverride };
                        }
                    }

                    const slideXml = await getNormalizedXmlString(entriesMap, slidePath);

                    const slideXmlDoc = parseXmlString(slideXml, `slide ${slideId}`);
                    const layoutXmlDoc = layoutXml ? parseXmlString(layoutXml, `layout for slide ${slideId}`) : null;
                    const masterXmlDoc = masterXml ? parseXmlString(masterXml, `master for slide ${slideId}`) : null;

                    const sldNode = slideXmlDoc.getElementsByTagNameNS("http://schemas.openxmlformats.org/presentationml/2006/main", 'sld')[0];
                    const showMasterShapes = !sldNode || sldNode.getAttribute('showMasterSp') !== '0';

                    const slideBg = parseBackground(slideXmlDoc, slideContext);
                    const layoutBg = layoutXmlDoc ? parseBackground(layoutXmlDoc, slideContext) : null;
                    const masterBg = masterXmlDoc ? parseBackground(masterXmlDoc, slideContext) : null;
                    const finalBg = slideBg || layoutBg || masterBg;

                    const slideContainer = document.createElement( 'div' );
                    slideContainer.className = 'slide-viewer';
                    slideContainer.id = `slide-${ i + 1 }`;
                    slideContainer.style.aspectRatio = `${slideSize.width} / ${slideSize.height}`;
                    slideViewerContainer.appendChild( slideContainer );

                    // The renderSlide function now handles its own scaling.
                    await renderSlide( slideXml, slideContainer, finalPlaceholders, i + 1, slideSize, defaultTextStyles, imageMap, slideContext, finalBg, showMasterShapes, masterStaticShapes, layoutStaticShapes, slideRels, entriesMap );
                }

            } catch ( error ) {
                console.error( 'Error parsing the presentation:', error );
                fileInfo.textContent = `Error: Could not parse presentation. ${ error.message }`;
            } finally {
                await zipReader.close();
                loadingIndicator.style.display = 'none';
            }
        } );

        async function getRelationships(entriesMap, path) {
            let xmlString = await getNormalizedXmlString(entriesMap, path);
            if (!xmlString) return {};

            const rels = {};
            // Use regex to parse relationships to be resilient to XML parsing errors.
            const relRegex = /<Relationship\s+([^>]+)\/?>/g;
            const attrRegex = /(\w+)="([^"]+)"/g;

            let match;
            while ((match = relRegex.exec(xmlString)) !== null) {
                const attrs = {};
                const attributesString = match[1];
                for (const attrMatch of attributesString.matchAll(attrRegex)) {
                    attrs[attrMatch[1]] = attrMatch[2];
                }

                if (attrs.Id && attrs.Type && attrs.Target) {
                    rels[attrs.Id] = {
                        id: attrs.Id,
                        type: attrs.Type,
                        target: attrs.Target
                    };
                }
            }
            return rels;
        }

        function getSlideOrder(xmlString) {
            const ids = [];
            const regex = /<[^>:]*:sldId[^>]+r:id="([^"]+)"/g;
            let match;
            while ((match = regex.exec(xmlString)) !== null) {
                ids.push(match[1]);
            }
            return ids;
        }

        function getSlideSize(xmlString) {
            // Two-step regex for robustness: first find the tag, then find the attributes within it.
            const sldSzTagMatch = xmlString.match(/<[^>:]*:sldSz\s+([^>]+)\/?>/);
            if (sldSzTagMatch) {
                const attrs = sldSzTagMatch[1];
                const cxMatch = attrs.match(/cx="([^"]+)"/);
                const cyMatch = attrs.match(/cy="([^"]+)"/);
                if (cxMatch && cyMatch) {
                    const cx = parseInt(cxMatch[1]);
                    const cy = parseInt(cyMatch[1]);
                    return { width: cx / EMU_PER_PIXEL, height: cy / EMU_PER_PIXEL };
                }
            }
            return { width: 960, height: 720 }; // Default size
        }

        function getAutoNumberingChar(scheme, number) {
            switch (scheme) {
                case 'alphaLcParenBoth': return `(${String.fromCharCode(96 + number)})`;
                case 'alphaLcParenR': return `${String.fromCharCode(96 + number)})`;
                case 'alphaLcPeriod': return `${String.fromCharCode(96 + number)}.`;
                case 'alphaUcParenBoth': return `(${String.fromCharCode(64 + number)})`;
                case 'alphaUcParenR': return `${String.fromCharCode(64 + number)})`;
                case 'alphaUcPeriod': return `${String.fromCharCode(64 + number)}.`;
                case 'arabicParenBoth': return `(${number})`;
                case 'arabicParenR': return `${number})`;
                case 'arabicPeriod': return `${number}.`;
                case 'arabicPlain': return `${number}`;
                // TODO: Implement Roman numeral conversion
                case 'romanLcParenBoth': return `(i)`;
                case 'romanLcParenR': return `i)`;
                case 'romanLcPeriod': return `i.`;
                case 'romanUcParenBoth': return `(I)`;
                case 'romanUcParenR': return `I)`;
                case 'romanUcPeriod': return `I.`;
                default: return `${number}.`;
            }
        }

        function createImage(url) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = url;
            });
        }

        function parseTheme(themeXml) {
            const xmlDoc = parseXmlString(themeXml, "theme");
            const theme = {
                colorScheme: {},
                fontScheme: {},
                formatScheme: {
                    fills: [],
                    lines: [],
                    effects: [],
                },
            };

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const clrSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'clrScheme')[0];
            if (clrSchemeNode) {
                for (const child of clrSchemeNode.children) {
                    const colorName = child.localName;
                    const srgbClrNode = child.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
                    if (srgbClrNode) {
                        theme.colorScheme[colorName] = `#${srgbClrNode.getAttribute('val')}`;
                    }
                    const sysClrNode = child.getElementsByTagNameNS(DML_NS, 'sysClr')[0];
                    if (sysClrNode) {
                        const lastColor = sysClrNode.getAttribute('lastClr');
                        if (lastColor) {
                            // Use lastClr as a fallback, it's often more reliable
                            theme.colorScheme[colorName] = `#${lastColor}`;
                        }
                        // If no lastClr, we don't set a color, letting it fall back to default.
                    }
                }
            }

            const fontSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'fontScheme')[0];
            if (fontSchemeNode) {
                const majorFontNode = fontSchemeNode.getElementsByTagNameNS(DML_NS, 'majorFont')[0];
                if (majorFontNode) {
                    const latinFontNode = majorFontNode.getElementsByTagNameNS(DML_NS, 'latin')[0];
                    if (latinFontNode) {
                        theme.fontScheme.major = latinFontNode.getAttribute('typeface');
                    }
                }
                const minorFontNode = fontSchemeNode.getElementsByTagNameNS(DML_NS, 'minorFont')[0];
                if (minorFontNode) {
                    const latinFontNode = minorFontNode.getElementsByTagNameNS(DML_NS, 'latin')[0];
                    if (latinFontNode) {
                        theme.fontScheme.minor = latinFontNode.getAttribute('typeface');
                    }
                }
            }

            const fmtSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'fmtScheme')[0];
            if (fmtSchemeNode) {
                const fillStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'fillStyleLst')[0];
                if (fillStyleLstNode) {
                    for (const fillNode of fillStyleLstNode.children) {
                        if (fillNode.localName === 'solidFill') {
                            const colorObj = parseColor(fillNode);
                            theme.formatScheme.fills.push({ type: 'solid', color: colorObj });
                        } else {
                            // TODO: Handle other fill types like gradFill, etc.
                            theme.formatScheme.fills.push({ type: 'unsupported' });
                        }
                    }
                }

                const lnStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'lnStyleLst')[0];
                if (lnStyleLstNode) {
                    for (const lineNode of lnStyleLstNode.children) {
                        const width = parseInt(lineNode.getAttribute('w') || '9525');
                        const cap = lineNode.getAttribute('cap');
                        const cmpd = lineNode.getAttribute('cmpd');

                        const solidFillNode = lineNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                        if (solidFillNode) {
                            const colorObj = parseColor(solidFillNode);
                            theme.formatScheme.lines.push({ type: 'solid', color: colorObj, width: width / EMU_PER_PIXEL, cap, cmpd });
                        } else {
                            theme.formatScheme.lines.push({ type: 'unsupported' });
                        }
                    }
                }

                 const effectStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'effectStyleLst')[0];
                 if (effectStyleLstNode) {
                    // TODO: Implement effect parsing if needed
                 }
            }

            return theme;
        }

        function parseColorMap(node) {
            const colorMap = {};
            if (node) {
                for (const attr of node.attributes) {
                    colorMap[attr.name] = attr.value;
                }
            }
            return colorMap;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1).toUpperCase();
        }

        function applyTint(hex, tint) {
            const base = hexToRgb(hex);
            if (!base) return hex;
            const amount = tint / 100000; // Tint is provided as e.g. 80000 for 80%
            const r = base.r * (1 - amount) + 255 * amount;
            const g = base.g * (1 - amount) + 255 * amount;
            const b = base.b * (1 - amount) + 255 * amount;
            return rgbToHex(r, g, b);
        }

        function applyShade(hex, shade) {
            const base = hexToRgb(hex);
            if (!base) return hex;
            const amount = shade / 100000; // Shade is provided as e.g. 80000 for 80%
            const r = base.r * (1 - amount);
            const g = base.g * (1 - amount);
            const b = base.b * (1 - amount);
            return rgbToHex(r, g, b);
        }

        function parseColor(colorNode) {
            if (!colorNode) return null;

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const srgbClrNode = colorNode.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
            if (srgbClrNode) {
                const color = { srgb: `#${srgbClrNode.getAttribute('val')}` };
                const alphaNode = srgbClrNode.getElementsByTagNameNS(DML_NS, 'alpha')[0];
                if (alphaNode) color.alpha = parseInt(alphaNode.getAttribute('val'));
                return color;
            }

            const schemeClrNode = colorNode.getElementsByTagNameNS(DML_NS, 'schemeClr')[0];
            if (schemeClrNode) {
                const color = { scheme: schemeClrNode.getAttribute('val') };
                const tintNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'tint')[0];
                if (tintNode) color.tint = parseInt(tintNode.getAttribute('val'));

                const shadeNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'shade')[0];
                if (shadeNode) color.shade = parseInt(shadeNode.getAttribute('val'));

                const alphaNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'alpha')[0];
                if (alphaNode) color.alpha = parseInt(alphaNode.getAttribute('val'));

                // TODO: Add other transformations like lumMod, lumOff, etc.
                return color;
            }

            return null;
        }

        function resolveColor(colorObj, slideContext) {
            if (!colorObj || !slideContext.theme) {
                return null;
            }

            let hex;
            if (colorObj.srgb) {
                hex = colorObj.srgb;
            } else if (colorObj.scheme) {
                let themeColorName = slideContext.colorMap[colorObj.scheme] || colorObj.scheme;
                if (themeColorName === 'phClr') {
                    // phClr is context-dependent. For a robust default, we'll map it
                    // to a visible accent color like accent1.
                    themeColorName = 'accent1';
                }
                if (themeColorName && slideContext.theme.colorScheme[themeColorName]) {
                    hex = slideContext.theme.colorScheme[themeColorName];
                    if (colorObj.tint) hex = applyTint(hex, colorObj.tint);
                    if (colorObj.shade) hex = applyShade(hex, colorObj.shade);
                }
            }

            if (hex) {
                if (colorObj.alpha) {
                    const rgb = hexToRgb(hex);
                    if (rgb) {
                        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${colorObj.alpha / 100000})`;
                    }
                }
                return hex;
            }

            return null; // Return null if color can't be resolved
        }

        function parseTableStyles(xmlString) {
            const xmlDoc = parseXmlString(xmlString, "tableStyles");
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const styles = {};

            const tblStyleNodes = xmlDoc.getElementsByTagNameNS(DML_NS, 'tblStyle');

            for (const styleNode of tblStyleNodes) {
                const styleId = styleNode.getAttribute('styleId');
                const styleDef = {};

                const styleParts = ['wholeTbl', 'band1H', 'band2H', 'band1V', 'band2V', 'firstRow', 'lastRow', 'firstCol', 'lastCol', 'nwCell', 'neCell', 'swCell', 'seCell'];

                for (const partName of styleParts) {
                    const partNode = styleNode.getElementsByTagNameNS(DML_NS, partName)[0];
                    if (partNode) {
                        styleDef[partName] = parseStylePart(partNode);
                    }
                }
                // The ID in the slide is wrapped in braces, but not in the style definition
                styles[`{${styleId}}`] = styleDef;
            }

            return styles;
        }

        function parseStylePart(partNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const partDef = {
                tcStyle: {},
                tcTxStyle: {}
            };

            const tcStyleNode = partNode.getElementsByTagNameNS(DML_NS, 'tcStyle')[0];
            if (tcStyleNode) {
                const fillNode = tcStyleNode.getElementsByTagNameNS(DML_NS, 'fill')[0];
                if (fillNode) {
                    const solidFillNode = fillNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                    if (solidFillNode) {
                        partDef.tcStyle.fill = parseColor(solidFillNode);
                    }
                }

                const tcBdrNode = tcStyleNode.getElementsByTagNameNS(DML_NS, 'tcBdr')[0];
                if (tcBdrNode) {
                    partDef.tcStyle.borders = {};
                    const borderTypes = ['left', 'right', 'top', 'bottom'];
                    for (const type of borderTypes) {
                        const borderNode = tcBdrNode.getElementsByTagNameNS(DML_NS, type)[0];
                        if (borderNode) {
                            const lnNode = borderNode.getElementsByTagNameNS(DML_NS, 'ln')[0];
                            if (lnNode) {
                                const width = parseInt(lnNode.getAttribute('w') || '9525') / EMU_PER_PIXEL;
                                const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                                if (solidFillNode) {
                                    const colorObj = parseColor(solidFillNode);
                                    if (colorObj) {
                                        partDef.tcStyle.borders[type] = {
                                            width: width,
                                            color: colorObj
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }

            const tcTxStyleNode = partNode.getElementsByTagNameNS(DML_NS, 'tcTxStyle')[0];
            if (tcTxStyleNode) {
                // TODO: Parse text styles for tables (bold, italic, color, etc.)
            }

            return partDef;
        }

        function parseBackground(xmlDoc, slideContext) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const bgNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'bg')[0];
            if (!bgNode) return null;

            const bgPrNode = bgNode.getElementsByTagNameNS(PML_NS, 'bgPr')[0];
            if (bgPrNode) {
                const solidFillNode = bgPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                if (solidFillNode) {
                    const colorObj = parseColor(solidFillNode);
                    if (colorObj) {
                        return { type: 'color', value: resolveColor(colorObj, slideContext) };
                    }
                }

                const blipFillNode = bgPrNode.getElementsByTagNameNS(DML_NS, 'blipFill')[0];
                if (blipFillNode) {
                    const blipNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                    if (blipNode) {
                        const relId = blipNode.getAttribute('r:embed');
                        return { type: 'image', relId: relId };
                    }
                }
            }

            return null;
        }

        function parseCustomGeometry(custGeomNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const pathLstNode = custGeomNode.getElementsByTagNameNS(DML_NS, 'pathLst')[0];
            if (!pathLstNode) return null;

            // The spec allows multiple paths, but for now, we'll handle the common case of one.
            const pathNode = pathLstNode.getElementsByTagNameNS(DML_NS, 'path')[0];
            if (!pathNode) return null;

            const pathW = parseInt(pathNode.getAttribute('w'));
            const pathH = parseInt(pathNode.getAttribute('h'));

            let svgPath = "";
            // Using childNodes to preserve order
            for (const cmdNode of pathNode.childNodes) {
                // Skip non-element nodes like #text
                if (cmdNode.nodeType !== 1) continue;

                const cmd = cmdNode.localName;

                switch (cmd) {
                    case 'moveTo': {
                        const ptNode = cmdNode.getElementsByTagNameNS(DML_NS, 'pt')[0];
                        if (ptNode) {
                            const x = ptNode.getAttribute('x');
                            const y = ptNode.getAttribute('y');
                            svgPath += `M ${x} ${y} `;
                        }
                        break;
                    }
                    case 'lnTo': {
                        const ptNode = cmdNode.getElementsByTagNameNS(DML_NS, 'pt')[0];
                        if (ptNode) {
                            const x = ptNode.getAttribute('x');
                            const y = ptNode.getAttribute('y');
                            svgPath += `L ${x} ${y} `;
                        }
                        break;
                    }
                    case 'cubicBezTo': {
                        const ptNodes = cmdNode.getElementsByTagNameNS(DML_NS, 'pt');
                        if (ptNodes.length === 3) {
                            const x1 = ptNodes[0].getAttribute('x');
                            const y1 = ptNodes[0].getAttribute('y');
                            const x2 = ptNodes[1].getAttribute('x');
                            const y2 = ptNodes[1].getAttribute('y');
                            const x3 = ptNodes[2].getAttribute('x');
                            const y3 = ptNodes[2].getAttribute('y');
                            svgPath += `C ${x1} ${y1} ${x2} ${y2} ${x3} ${y3} `;
                        }
                        break;
                    }
                    case 'quadBezTo': {
                        const ptNodes = cmdNode.getElementsByTagNameNS(DML_NS, 'pt');
                        if (ptNodes.length === 2) {
                            const x1 = ptNodes[0].getAttribute('x');
                            const y1 = ptNodes[0].getAttribute('y');
                            const x2 = ptNodes[1].getAttribute('x');
                            const y2 = ptNodes[1].getAttribute('y');
                            svgPath += `Q ${x1} ${y1} ${x2} ${y2} `;
                        }
                        break;
                    }
                    case 'arcTo': {
                         // Not implemented, as it's not in the provided XML and requires complex calculations.
                         break;
                    }
                    case 'close': {
                        svgPath += 'Z ';
                        break;
                    }
                }
            }

            if (svgPath === "") return null;

            return {
                path: svgPath.trim(),
                w: pathW,
                h: pathH,
            };
        }

        function parseLineProperties(lnNode, slideContext) {
            if (!lnNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const noFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
            if (noFillNode) return 'none';

            const props = {
                width: parseInt(lnNode.getAttribute('w') || '9525') / EMU_PER_PIXEL,
                cap: lnNode.getAttribute('cap'), // rnd, sq, flat
                join: null // miter, round, bevel
            };

            const roundNode = lnNode.getElementsByTagNameNS(DML_NS, 'round')[0];
            if (roundNode) props.join = 'round';

            const bevelNode = lnNode.getElementsByTagNameNS(DML_NS, 'bevel')[0];
            if (bevelNode) props.join = 'bevel';

            const miterNode = lnNode.getElementsByTagNameNS(DML_NS, 'miter')[0];
            if (miterNode) props.join = 'miter';

            const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
            if (solidFillNode) {
                props.color = resolveColor(parseColor(solidFillNode), slideContext);
            }

            if (!props.color) return 'none';

            return props;
        }

        function parseShapeProperties(shapeNode, slideContext) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const spPrNode = shapeNode.getElementsByTagNameNS(PML_NS, 'spPr')[0];
            if (!spPrNode) return { fill: 'none', stroke: 'none', geometry: null };

            const properties = { fill: null, stroke: null, geometry: null };

            const prstGeomNode = spPrNode.getElementsByTagNameNS(DML_NS, 'prstGeom')[0];
            if (prstGeomNode) {
                properties.geometry = { type: 'preset', preset: prstGeomNode.getAttribute('prst') };
            }

            const custGeomNode = spPrNode.getElementsByTagNameNS(DML_NS, 'custGeom')[0];
            if (custGeomNode) {
                properties.geometry = { type: 'custom', path: parseCustomGeometry(custGeomNode) };
            }

            const noFillNode = spPrNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
            const solidFillNode = spPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
            const gradFillNode = spPrNode.getElementsByTagNameNS(DML_NS, 'gradFill')[0];

            if (noFillNode) {
                properties.fill = 'none';
            } else if (solidFillNode) {
                const colorObj = parseColor(solidFillNode);
                if (colorObj) properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
            } else if (gradFillNode) {
                const gsLstNode = gradFillNode.getElementsByTagNameNS(DML_NS, 'gsLst')[0];
                const stops = [];
                if (gsLstNode) {
                    for (const gsNode of gsLstNode.children) {
                        const pos = parseInt(gsNode.getAttribute('pos')) / 100000;
                        const colorObj = parseColor(gsNode);
                        if (colorObj) {
                            stops.push({ pos, color: resolveColor(colorObj, slideContext) });
                        }
                    }
                }
                let angle = 0;
                const linNode = gradFillNode.getElementsByTagNameNS(DML_NS, 'lin')[0];
                if (linNode) {
                    angle = parseInt(linNode.getAttribute('ang')) / 60000;
                }
                properties.fill = { type: 'gradient', stops, angle };
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const fillRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'fillRef')[0];
                    if (fillRefNode) {
                        const idx = parseInt(fillRefNode.getAttribute('idx'));
                        if (idx > 0 && slideContext.theme.formatScheme.fills[idx - 1]) {
                            const themeFill = slideContext.theme.formatScheme.fills[idx - 1];
                            // The fillRef can have its own color definitions that override the theme
                            let colorObj = parseColor(fillRefNode) || themeFill.color;

                            if (themeFill.type === 'solid') {
                                properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                            } else if (themeFill.type === 'gradient') {
                                // TODO: Handle gradient fills from themes
                            }
                        } else {
                             properties.fill = 'none';
                        }
                    }
                }
            }

            const lnNode = spPrNode.getElementsByTagNameNS(DML_NS, 'ln')[0];
            if (lnNode) {
                properties.stroke = parseLineProperties(lnNode, slideContext);
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const lnRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'lnRef')[0];
                    if (lnRefNode) {
                        const idx = parseInt(lnRefNode.getAttribute('idx'));
                        if (idx > 0 && slideContext.theme.formatScheme.lines[idx - 1]) {
                             const themeLine = slideContext.theme.formatScheme.lines[idx - 1];
                             if (themeLine.type === 'solid') {
                                // Start with the theme line properties
                                const strokeProps = { ...themeLine };

                                // The lnRef can have its own color that overrides the theme one
                                const lnRefColorObj = parseColor(lnRefNode);
                                if (lnRefColorObj) {
                                    strokeProps.color = resolveColor(lnRefColorObj, slideContext);
                                } else {
                                    // If no override, resolve the theme color
                                    strokeProps.color = resolveColor(themeLine.color, slideContext);
                                }

                                properties.stroke = strokeProps;
                             }
                        } else {
                            properties.stroke = 'none';
                        }
                    }
                }
            }

            // If no fill is defined, apply the default from the theme
            if (!properties.fill) {
                if (slideContext.theme?.formatScheme?.fills?.[0]?.type === 'solid') {
                     const themeFill = slideContext.theme.formatScheme.fills[0];
                     properties.fill = { type: 'solid', color: resolveColor(themeFill.color, slideContext) };
                }
            }

            // If no stroke is defined, apply the default from the theme
            if (!properties.stroke) {
                if (slideContext.theme?.formatScheme?.lines?.[0]?.type === 'solid') {
                    const themeLine = slideContext.theme.formatScheme.lines[0];
                    const strokeProps = { ...themeLine };
                    strokeProps.color = resolveColor(themeLine.color, slideContext);
                    properties.stroke = strokeProps;
                }
            }
            return properties;
        }

        function parseTextStyle(styleNode) {
            if (!styleNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const styles = {};
            for (let i = 1; i <= 9; i++) {
                const lvlPr = styleNode.getElementsByTagNameNS(DML_NS, `lvl${i}pPr`)[0];
                if (lvlPr) {
                    styles[i - 1] = parseParagraphProperties(lvlPr);
                }
            }
            return styles;
        }

        function parseParagraphProperties(pPrNode) {
            if (!pPrNode) return {};

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const properties = { bullet: {}, defRPr: {} };

            const marL = pPrNode.getAttribute('marL');
            if (marL) properties.indent = parseInt(marL) / EMU_PER_PIXEL;

            const buNone = pPrNode.getElementsByTagNameNS(DML_NS, 'buNone')[0];
            if (buNone) properties.bullet.type = 'none';

            const buChar = pPrNode.getElementsByTagNameNS(DML_NS, 'buChar')[0];
            if (buChar) {
                properties.bullet.type = 'char';
                properties.bullet.char = buChar.getAttribute('char');
            }

            const buAutoNum = pPrNode.getElementsByTagNameNS(DML_NS, 'buAutoNum')[0];
            if (buAutoNum) {
                properties.bullet.type = 'auto';
                properties.bullet.scheme = buAutoNum.getAttribute('type');
                properties.bullet.startAt = parseInt(buAutoNum.getAttribute('startAt') || '1');
            }

            const buBlip = pPrNode.getElementsByTagNameNS(DML_NS, 'buBlip')[0];
            if (buBlip) {
                const blip = buBlip.getElementsByTagNameNS(DML_NS, 'blip')[0];
                if (blip) {
                    properties.bullet.type = 'image';
                    properties.bullet.relId = blip.getAttribute('r:embed');
                }
            }

            const buSzPct = pPrNode.getElementsByTagNameNS(DML_NS, 'buSzPct')[0];
            if (buSzPct) {
                properties.bullet.size = `${parseInt(buSzPct.getAttribute('val')) / 1000}%`;
            }

            const buSzPts = pPrNode.getElementsByTagNameNS(DML_NS, 'buSzPts')[0];
            if (buSzPts) {
                properties.bullet.size = `${parseInt(buSzPts.getAttribute('val')) / 100}pt`;
            }

            const buClr = pPrNode.getElementsByTagNameNS(DML_NS, 'buClr')[0];
            if (buClr) {
                // Here, the color element is not a solidFill, but a direct child
                const srgbClr = buClr.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
                if (srgbClr) {
                    properties.bullet.color = { srgb: `#${srgbClr.getAttribute('val')}` };
                }
                const schemeClr = buClr.getElementsByTagNameNS(DML_NS, 'schemeClr')[0];
                if (schemeClr) {
                    properties.bullet.color = parseColor(buClr);
                }
            }

            const defRPrNode = pPrNode.getElementsByTagNameNS(DML_NS, 'defRPr')[0];
            if (defRPrNode) {
                properties.defRPr.size = parseInt(defRPrNode.getAttribute('sz') || '1800') / 100;
                properties.defRPr.bold = defRPrNode.getAttribute('b') === '1';
                properties.defRPr.italic = defRPrNode.getAttribute('i') === '1';

                const solidFillNode = defRPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                if (solidFillNode) {
                    properties.defRPr.color = parseColor(solidFillNode);
                }
            }

            return properties;
        }

        function parseMasterOrLayout(xml, isLayout = false) {
            const xmlDoc = parseXmlString(xml, isLayout ? "slideLayout" : "slideMaster");
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const spNodes = Array.from(xmlDoc.getElementsByTagNameNS(PML_NS, 'sp'));
            const cxnSpNodes = Array.from(xmlDoc.getElementsByTagNameNS(PML_NS, 'cxnSp'));
            const shapeNodes = [...spNodes, ...cxnSpNodes];
            const placeholders = {};
            const staticShapes = [];
            const defaultTextStyles = {};
            let colorMap = null;
            let colorMapOverride = null;

            if (isLayout) {
                const clrMapOvrNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'clrMapOvr')[0];
                if (clrMapOvrNode) {
                    const overrideNode = clrMapOvrNode.getElementsByTagNameNS(DML_NS, 'overrideClrMapping')[0];
                    if (overrideNode) {
                        colorMapOverride = parseColorMap(overrideNode);
                    }
                }
            } else {
                const clrMapNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'clrMap')[0];
                colorMap = parseColorMap(clrMapNode);
            }

            const txStyles = xmlDoc.getElementsByTagNameNS(PML_NS, 'txStyles')[0];
            if (txStyles) {
                defaultTextStyles.title = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'titleStyle')[0]);
                defaultTextStyles.body = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'bodyStyle')[0]);
                defaultTextStyles.other = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'otherStyle')[0]);
            }

            for (const sp of shapeNodes) {
                const nvPr = sp.getElementsByTagNameNS(PML_NS, 'nvPr')[0];
                const ph = nvPr ? nvPr.getElementsByTagNameNS(PML_NS, 'ph')[0] : null;

                let isStaticShape = false;

                if (ph) {
                    // This shape is a placeholder, so create an entry for it.
                    const type = ph.getAttribute('type');
                    const idx = ph.getAttribute('idx');
                    const key = idx ? `idx_${idx}` : type;

                    const xfrmNode = sp.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
                    if (xfrmNode) {
                        const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                        const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                        if (offNode && extNode) {
                            const pos = {
                                x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                                y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                                width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                                height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                            };
                            let listStyle = null;
                            const txBodyNode = sp.getElementsByTagNameNS(PML_NS, 'txBody')[0];
                            if (txBodyNode) {
                                const lstStyleNode = txBodyNode.getElementsByTagNameNS(DML_NS, 'lstStyle')[0];
                                if (lstStyleNode) {
                                    listStyle = parseTextStyle(lstStyleNode);
                                }
                            }
                            placeholders[key] = { pos, type, listStyle };
                        }
                    }

                    // Decide if the placeholder's own geometry should be rendered.
                    // Picture placeholders often have a visible shape.
                    if (type === 'pic') {
                        isStaticShape = true;
                    }
                } else {
                    // This shape is not a placeholder, so it must be a static shape.
                    isStaticShape = true;
                }

                if (isStaticShape) {
                    staticShapes.push(sp);
                }
            }
            return { placeholders, staticShapes, defaultTextStyles, colorMap, colorMapOverride };
        }

        async function processShape(shape, layer, layoutPlaceholders, slideContext, imageMap, listCounters, parentXfrm, defaultTextStyles) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            let pos = null;
            const nvPr = shape.getElementsByTagNameNS(PML_NS, 'nvPr')[0];
            let phKey = null, phType = null;
            if (nvPr) {
                const placeholder = nvPr.getElementsByTagNameNS(PML_NS, 'ph')[0];
                if (placeholder) {
                    phType = placeholder.getAttribute('type');
                    const phIdx = placeholder.getAttribute('idx');
                    phKey = phIdx ? `idx_${phIdx}` : phType;
                }
            }

            const xfrmNode = shape.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    pos = {
                        x: (parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL) + parentXfrm.x,
                        y: (parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL) + parentXfrm.y,
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                        rotation: parseInt(xfrmNode.getAttribute('rot') || '0') / 60000,
                        flipH: xfrmNode.getAttribute('flipH') === '1',
                        flipV: xfrmNode.getAttribute('flipV') === '1',
                    };
                }
            } else if (phKey && layoutPlaceholders[phKey]) {
                pos = { ...layoutPlaceholders[phKey].pos };
                pos.x += parentXfrm.x;
                pos.y += parentXfrm.y;
            } else if (phType === 'ctrTitle' && layoutPlaceholders['title']) {
                // Fallback for centered titles, which often use the standard 'title' placeholder
                pos = { ...layoutPlaceholders['title'].pos };
                pos.x += parentXfrm.x;
                pos.y += parentXfrm.y;
                phKey = 'title'; // Remap key for style inheritance
            }

            if (!pos) return { width: 0, height: 0 };

            const shapeProps = parseShapeProperties(shape, slideContext);
            let konvaShape;

            if (shapeProps && shapeProps.geometry) {
                if (shapeProps.geometry.type === 'preset') {
                    switch (shapeProps.geometry.preset) {
                        case 'rect':
                            konvaShape = new Konva.Rect({ x: pos.x, y: pos.y, width: pos.width, height: pos.height });
                            break;
                        case 'ellipse':
                            konvaShape = new Konva.Ellipse({ x: pos.x + pos.width / 2, y: pos.y + pos.height / 2, radiusX: pos.width / 2, radiusY: pos.height / 2 });
                            break;
                        case 'line':
                            konvaShape = new Konva.Line({ points: [pos.x, pos.y, pos.x + pos.width, pos.y + pos.height] });
                            break;
                    }
                } else if (shapeProps.geometry.type === 'custom' && shapeProps.geometry.path) {
                    const pathData = shapeProps.geometry.path;
                    konvaShape = new Konva.Path({
                        x: pos.x,
                        y: pos.y,
                        data: pathData.path,
                    });
                    // The path from custGeom has its own coordinate system. We need to scale it
                    // to the actual shape's dimensions (`pos.width`, `pos.height`).
                    const scaleX = pathData.w === 0 ? 1 : pos.width / pathData.w;
                    const scaleY = pathData.h === 0 ? 1 : pos.height / pathData.h;
                    konvaShape.scale({ x: scaleX, y: scaleY });
                }

                if (konvaShape) {
                    if (shapeProps.fill && shapeProps.fill !== 'none') {
                        if (shapeProps.fill.type === 'solid') {
                            konvaShape.fill(shapeProps.fill.color);
                        } else if (shapeProps.fill.type === 'gradient') {
                            const angleRad = shapeProps.fill.angle * Math.PI / 180;
                            const x = pos.width / 2;
                            const y = pos.height / 2;
                            konvaShape.fillLinearGradientStartPoint({ x: x - Math.cos(angleRad) * x, y: y - Math.sin(angleRad) * y });
                            konvaShape.fillLinearGradientEndPoint({ x: x + Math.cos(angleRad) * x, y: y + Math.sin(angleRad) * y });
                            konvaShape.fillLinearGradientColorStops(shapeProps.fill.stops.flatMap(stop => [stop.pos, stop.color]));
                        }
                    } else {
                        konvaShape.fillEnabled(false);
                    }

                    if (shapeProps.stroke && shapeProps.stroke !== 'none') {
                        konvaShape.stroke(shapeProps.stroke.color);
                        konvaShape.strokeWidth(shapeProps.stroke.width || 1);

                        if (shapeProps.stroke.join) {
                            konvaShape.lineJoin(shapeProps.stroke.join); // 'miter', 'round', 'bevel'
                        }

                        if (shapeProps.stroke.cap) {
                            // XML 'rnd' -> Konva 'round', 'sq' -> 'square', 'flat' -> 'butt'
                            let lineCap = 'butt';
                            if (shapeProps.stroke.cap === 'rnd') lineCap = 'round';
                            if (shapeProps.stroke.cap === 'sq') lineCap = 'square';
                            konvaShape.lineCap(lineCap);
                        }
                    } else {
                        konvaShape.strokeEnabled(false);
                    }

                    konvaShape.rotation(pos.rotation || 0);
                    if (pos.flipH) konvaShape.scaleX(-1);
                    if (pos.flipV) konvaShape.scaleY(-1);

                    layer.add(konvaShape);
                }
            }

            const txBody = shape.getElementsByTagNameNS(PML_NS, 'txBody')[0];
            if (txBody) {
                const lstStyle = txBody.getElementsByTagNameNS(DML_NS, 'lstStyle')[0];
                const textGroup = new Konva.Group({ clip: { x: pos.x, y: pos.y, width: pos.width, height: pos.height } });
                layer.add(textGroup);
                let currentY = pos.y;
                let paragraphMaxHeight = 0;

                const paragraphs = Array.from(shape.getElementsByTagNameNS(DML_NS, 'p'));

                for (const pNode of paragraphs) {
                    const pPrNode = pNode.getElementsByTagNameNS(DML_NS, 'pPr')[0];
                    const level = pPrNode ? parseInt(pPrNode.getAttribute('lvl') || '0') : 0;
                    let defaultStyle = defaultTextStyles.other;
                    if (phType === 'title' || phType === 'ctrTitle' || phType === 'subTitle') defaultStyle = defaultTextStyles.title;
                    else if (phType === 'body') defaultStyle = defaultTextStyles.body;

                    const defaultLevelProps = (defaultStyle && defaultStyle[level]) ? defaultStyle[level] : {};
                    const layoutListStyle = (layoutPlaceholders[phKey]?.listStyle?.[level]) || {};
                    const slideLevelProps = parseParagraphProperties(pPrNode) || { bullet: {}, defRPr: {} };

                    const finalProps = {
                        ...defaultLevelProps, ...layoutListStyle, ...slideLevelProps,
                        bullet: { ...defaultLevelProps.bullet, ...layoutListStyle.bullet, ...slideLevelProps.bullet },
                        defRPr: { ...defaultLevelProps.defRPr, ...layoutListStyle.defRPr, ...slideLevelProps.defRPr }
                    };

                    const indent = finalProps.indent || (level * INDENTATION_AMOUNT);
                    let currentX = pos.x + indent;
                    let bulletOffset = 0;

                    currentY += paragraphMaxHeight;
                    paragraphMaxHeight = 0;

                    if (lstStyle && finalProps.bullet.type && finalProps.bullet.type !== 'none') {
                        let bulletEl;
                        const bulletColor = resolveColor(finalProps.bullet.color, slideContext);
                        const bulletFontSize = finalProps.defRPr.size || 18;

                        if (finalProps.bullet.type === 'char') {
                            bulletEl = new Konva.Text({ x: currentX, y: currentY, text: finalProps.bullet.char, fontSize: bulletFontSize, fontFamily: 'Arial', fill: bulletColor });
                        } else if (finalProps.bullet.type === 'auto') {
                            if (!listCounters[level]) listCounters[level] = finalProps.bullet.startAt || 1;
                            const bulletChar = getAutoNumberingChar(finalProps.bullet.scheme, listCounters[level]++);
                            bulletEl = new Konva.Text({ x: currentX, y: currentY, text: bulletChar, fontSize: bulletFontSize, fontFamily: 'Arial', fill: bulletColor });
                        } else if (finalProps.bullet.type === 'image' && finalProps.bullet.relId && imageMap[finalProps.bullet.relId]) {
                            const imageObj = await createImage(imageMap[finalProps.bullet.relId]);
                            bulletEl = new Konva.Image({ x: currentX, y: currentY, image: imageObj, width: 16, height: 16 });
                        }

                        if (bulletEl) {
                            textGroup.add(bulletEl);
                            bulletOffset = BULLET_OFFSET;
                            currentX += bulletOffset;
                        }
                    }

                    for (const childNode of pNode.childNodes) {
                        if (childNode.localName === 'r' || childNode.localName === 'fld') {
                            const rPr = childNode.getElementsByTagNameNS(DML_NS, 'rPr')[0];
                            const text = childNode.textContent.trim();
                            if (!text) continue;

                            const finalRunProps = { ...finalProps.defRPr };
                            if (rPr) {
                                if (rPr.getAttribute('sz')) finalRunProps.size = parseInt(rPr.getAttribute('sz')) / 100;
                                if (rPr.getAttribute('b') === '1') finalRunProps.bold = true; else if (rPr.getAttribute('b') === '0') finalRunProps.bold = false;
                                if (rPr.getAttribute('i') === '1') finalRunProps.italic = true; else if (rPr.getAttribute('i') === '0') finalRunProps.italic = false;
                                const solidFill = rPr.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                                if (solidFill) finalRunProps.color = parseColor(solidFill);
                            }

                            const textColor = resolveColor(finalRunProps.color, slideContext) || '#000000';
                            const fontSize = finalRunProps.size || 18;
                            const fontStyle = finalRunProps.bold && finalRunProps.italic ? 'bold italic' : finalRunProps.bold ? 'bold' : finalRunProps.italic ? 'italic' : 'normal';
                            let fontFamily = slideContext.theme?.fontScheme?.minor || 'Arial';
                            if (phType === 'title' || phType === 'ctrTitle' || phType === 'subTitle') {
                                fontFamily = slideContext.theme?.fontScheme?.major || 'Arial';
                            }

                            const textEl = new Konva.Text({
                                x: currentX,
                                y: currentY,
                                text: text,
                                fontSize: fontSize,
                                fontFamily: fontFamily,
                                fontStyle: fontStyle,
                                fill: textColor,
                                width: pos.width - (currentX - pos.x),
                            });
                            textGroup.add(textEl);
                            currentX += textEl.width();
                            paragraphMaxHeight = Math.max(paragraphMaxHeight, textEl.height());
                        } else if (childNode.localName === 'br') {
                            currentY += paragraphMaxHeight || LINE_HEIGHT;
                            currentX = pos.x + indent + bulletOffset;
                            paragraphMaxHeight = 0;
                        }
                    }
                }
            }
            return konvaShape ? konvaShape.getClientRect() : { width: 0, height: 0 };
        }

        function parseGroupShapeProperties(grpSpPrNode, slideContext) {
            if (!grpSpPrNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const properties = { fill: null, ext: null };

            const xfrmNode = grpSpPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
            if (xfrmNode) {
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'chExt')[0];
                if (extNode) {
                    properties.ext = {
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                    };
                }
            }

            const solidFillNode = grpSpPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
            if (solidFillNode) {
                const colorObj = parseColor(solidFillNode);
                if (colorObj) {
                    properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                }
            }
            return properties;
        }

        async function processGroupShape(group, layer, layoutPlaceholders, slideContext, imageMap, listCounters, parentXfrm, defaultTextStyles) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const grpSpPrNode = group.getElementsByTagNameNS(PML_NS, 'grpSpPr')[0];
            let groupXfrm = { x: parentXfrm.x, y: parentXfrm.y, rot: 0, flipH: false, flipV: false };
            let groupProps = null;

            if (grpSpPrNode) {
                groupProps = parseGroupShapeProperties(grpSpPrNode, slideContext);
                const xfrmNode = grpSpPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
                if (xfrmNode) {
                    const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                    if (offNode) {
                        groupXfrm.x += parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL;
                        groupXfrm.y += parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL;
                    }
                    groupXfrm.rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                    groupXfrm.flipH = xfrmNode.getAttribute('flipH') === '1';
                    groupXfrm.flipV = xfrmNode.getAttribute('flipV') === '1';
                }
            }

            if (groupProps && groupProps.fill && groupProps.ext) {
                const bgRect = new Konva.Rect({
                    x: groupXfrm.x,
                    y: groupXfrm.y,
                    width: groupProps.ext.width,
                    height: groupProps.ext.height,
                    fill: groupProps.fill.color,
                });
                layer.add(bgRect);
            }

            const konvaGroup = new Konva.Group({
                x: groupXfrm.x,
                y: groupXfrm.y,
            });
            konvaGroup.rotation(groupXfrm.rot);
            if (groupXfrm.flipH) konvaGroup.scaleX(-1);
            if (groupXfrm.flipV) konvaGroup.scaleY(-1);
            layer.add(konvaGroup);

            for (const element of group.children) {
                const tagName = element.localName;
                if (tagName === 'sp' || tagName === 'cxnSp') {
                    await processShape(element, konvaGroup, layoutPlaceholders, slideContext, imageMap, listCounters, { x: 0, y: 0 }, defaultTextStyles);
                } else if (tagName === 'grpSp') {
                    await processGroupShape(element, konvaGroup, layoutPlaceholders, slideContext, imageMap, listCounters, { x: 0, y: 0 }, defaultTextStyles);
                } else if (tagName === 'pic') {
                    await processPicture(element, konvaGroup, imageMap, { x: 0, y: 0 }, layoutPlaceholders);
                }
            }
        }

        function getCellBorders(cellNode, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const borders = {};
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];

            if (tcPrNode) {
                const borderMap = { 'lnL': 'left', 'lnR': 'right', 'lnT': 'top', 'lnB': 'bottom' };
                for (const child of tcPrNode.children) {
                    const side = borderMap[child.localName];
                    if (side) {
                        const lnNode = child;
                        const noFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
                        const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];

                        if (noFillNode) {
                            borders[side] = 'none';
                        } else if (solidFillNode) {
                            const colorObj = parseColor(solidFillNode);
                            const width = parseInt(lnNode.getAttribute('w') || '0') / EMU_PER_PIXEL;
                            if (colorObj && width > 0) {
                                borders[side] = {
                                    color: resolveColor(colorObj, slideContext),
                                    width: width
                                };
                            }
                        }
                    }
                }
            }
            // TODO: Fallback to table style for borders
            return borders;
        }

        function getCellFillColor(cellNode, tblPrNode, r, c, numRows, numCols, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            // Level 1: Direct Formatting
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];
            if (tcPrNode) {
                // Find the solidFill that is a direct child of tcPr, not nested in lnL, etc.
                let solidFillNode = null;
                for (const child of tcPrNode.children) {
                    if (child.localName === 'solidFill') {
                        solidFillNode = child;
                        break;
                    }
                }

                if (solidFillNode) {
                    const colorObj = parseColor(solidFillNode);
                    if (colorObj) {
                        return resolveColor(colorObj, slideContext);
                    }
                }
            }

            // Levels 2 & 3: Table Styles
            const tableStyleIdNode = tblPrNode ? tblPrNode.getElementsByTagNameNS(DML_NS, 'tableStyleId')[0] : null;
            if (!tableStyleIdNode) {
                return null;
            }

            const styleId = tableStyleIdNode.textContent;
            const tableStyle = slideContext.tableStyles[styleId];
            if (!tableStyle) {
                return null;
            }

            const firstRow = tblPrNode.getAttribute('firstRow') === '1';
            const lastRow = tblPrNode.getAttribute('lastRow') === '1';
            const firstCol = tblPrNode.getAttribute('firstCol') === '1';
            const lastCol = tblPrNode.getAttribute('lastCol') === '1';
            const bandRow = tblPrNode.getAttribute('bandRow') === '1';
            const bandCol = tblPrNode.getAttribute('bandCol') === '1';

            const isFirstRow = r === 0;
            const isLastRow = r === numRows - 1;
            const isFirstCol = c === 0;
            const isLastCol = c === numCols - 1;

            let stylePart = null;

            if (firstRow && isFirstRow && firstCol && isFirstCol && tableStyle.nwCell) { stylePart = tableStyle.nwCell; }
            else if (firstRow && isFirstRow && lastCol && isLastCol && tableStyle.neCell) { stylePart = tableStyle.neCell; }
            else if (lastRow && isLastRow && firstCol && isFirstCol && tableStyle.swCell) { stylePart = tableStyle.swCell; }
            else if (lastRow && isLastRow && lastCol && isLastCol && tableStyle.seCell) { stylePart = tableStyle.seCell; }
            else if (firstRow && isFirstRow && tableStyle.firstRow) { stylePart = tableStyle.firstRow; }
            else if (lastRow && isLastRow && tableStyle.lastRow) { stylePart = tableStyle.lastRow; }
            else if (firstCol && isFirstCol && tableStyle.firstCol) { stylePart = tableStyle.firstCol; }
            else if (lastCol && isLastCol && tableStyle.lastCol) { stylePart = tableStyle.lastCol; }
            else if (bandRow) {
                const isDataRow = !(firstRow && isFirstRow);
                if (isDataRow) {
                    if (r % 2 === 1 && tableStyle.band1H) { stylePart = tableStyle.band1H; }
                    else if (r % 2 === 0 && tableStyle.band2H) { stylePart = tableStyle.band2H; }
                }
            }

            if (!stylePart && bandCol) {
                const isDataCol = !(firstCol && isFirstCol) && !(lastCol && isLastCol);
                if (isDataCol) {
                    if (c % 2 === 1 && tableStyle.band1V) { stylePart = tableStyle.band1V; }
                    else if (c % 2 === 0 && tableStyle.band2V) { stylePart = tableStyle.band2V; }
                }
            }

            if (stylePart && stylePart.tcStyle && stylePart.tcStyle.fill) {
                return resolveColor(stylePart.tcStyle.fill, slideContext);
            }

            const wholeTblStyle = tableStyle.wholeTbl;
            if (wholeTblStyle && wholeTblStyle.tcStyle && wholeTblStyle.tcStyle.fill) {
                return resolveColor(wholeTblStyle.tcStyle.fill, slideContext);
            }

            return null;
        }

        async function processTable(graphicFrame, layer, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";

            // 1. Get position and size of the graphic frame
            const xfrmNode = graphicFrame.getElementsByTagNameNS(PML_NS, 'xfrm')[0];
            let pos = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    pos = {
                        x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                        y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                    };
                }
            }

            const tblNode = graphicFrame.getElementsByTagNameNS(DML_NS, 'tbl')[0];
            if (!tblNode) return {
                width: pos.width,
                height: pos.height
            };

            const tblPrNode = tblNode.getElementsByTagNameNS(DML_NS, 'tblPr')[0];

            const tableStyleIdNode = tblPrNode ? tblPrNode.getElementsByTagNameNS(DML_NS, 'tableStyleId')[0] : null;
            const styleId = tableStyleIdNode ? tableStyleIdNode.textContent : null;

            // 2. Parse grid and column widths
            const tblGridNode = tblNode.getElementsByTagNameNS(DML_NS, 'tblGrid')[0];
            const gridColNodes = tblGridNode ? tblGridNode.getElementsByTagNameNS(DML_NS, 'gridCol') : [];
            const colWidths = Array.from(gridColNodes).map(node => parseInt(node.getAttribute('w')) / EMU_PER_PIXEL);

            // 3. Iterate through rows and cells to build a renderable grid
            const rowNodes = Array.from(tblNode.getElementsByTagNameNS(DML_NS, 'tr'));
            const numRows = rowNodes.length;
            const numCols = colWidths.length;
            if (numRows === 0 || numCols === 0) return {
                width: pos.width,
                height: pos.height
            };

            const renderedGrid = Array(numRows).fill(0).map(() => Array(numCols).fill(false));

            for (let r = 0; r < numRows; r++) {
                const cellNodes = Array.from(rowNodes[r].getElementsByTagNameNS(DML_NS, 'tc'));

                for (let c = 0; c < numCols; c++) {
                    if (renderedGrid[r][c]) {
                        continue; // Already handled by a previous rowspan
                    }

                    const cellNode = cellNodes[c];
                    if (!cellNode) continue;

                    const hMerge = cellNode.getAttribute('hMerge') === '1';
                    const vMerge = cellNode.getAttribute('vMerge') === '1';

                    if (hMerge || vMerge) {
                        continue; // Handled by the primary cell of the merge
                    }

                    const gridSpan = parseInt(cellNode.getAttribute('gridSpan') || '1');
                    const rowSpan = parseInt(cellNode.getAttribute('rowSpan') || '1');

                    // Calculate cell dimensions based on spans
                    let cellWidth = 0;
                    for (let i = 0; i < gridSpan; i++) {
                        if (c + i < numCols) cellWidth += colWidths[c + i];
                    }

                    let cellHeight = 0;
                    for (let i = 0; i < rowSpan; i++) {
                        if (r + i < numRows) {
                            cellHeight += parseInt(rowNodes[r + i].getAttribute('h')) / EMU_PER_PIXEL;
                        }
                    }

                    // Calculate cell position
                    let cellX = pos.x;
                    for (let i = 0; i < c; i++) {
                        cellX += colWidths[i];
                    }

                    let cellY = pos.y;
                    for (let i = 0; i < r; i++) {
                        cellY += parseInt(rowNodes[i].getAttribute('h')) / EMU_PER_PIXEL;
                    }

                    // Mark grid cells covered by this span as rendered
                    for (let i = 0; i < rowSpan; i++) {
                        for (let j = 0; j < gridSpan; j++) {
                            if (r + i < numRows && c + j < numCols) {
                                renderedGrid[r + i][c + j] = true;
                            }
                        }
                    }

                    // Step 4: Get cell styling
                    const fillColor = getCellFillColor(cellNode, tblPrNode, r, c, numRows, numCols, slideContext);

                    const cellRect = new Konva.Rect({
                        x: cellX,
                        y: cellY,
                        width: cellWidth,
                        height: cellHeight,
                        fill: fillColor || 'transparent',
                    });
                    layer.add(cellRect);

                    // Draw borders using a strategy to avoid double-drawing
                    const borders = getCellBorders(cellNode, slideContext);
                    const borderDefs = {
                        top: { p: [cellX, cellY, cellX + cellWidth, cellY], draw: (r === 0) },
                        right: { p: [cellX + cellWidth, cellY, cellX + cellWidth, cellY + cellHeight], draw: true },
                        bottom: { p: [cellX + cellWidth, cellY + cellHeight, cellX, cellY + cellHeight], draw: true },
                        left: { p: [cellX, cellY + cellHeight, cellX, cellY], draw: (c === 0) },
                    };

                    for (const side in borderDefs) {
                        const borderStyle = borders[side];
                        if (borderStyle && borderStyle !== 'none' && borderDefs[side].draw) {
                            const border = new Konva.Line({
                                points: borderDefs[side].p,
                                stroke: borderStyle.color,
                                strokeWidth: borderStyle.width,
                                listening: false, // Make lines non-interactive
                            });
                            layer.add(border);
                        }
                    }

                    // Render text content
                    processCellText(cellNode, layer, cellX, cellY, cellWidth, cellHeight, slideContext);
                }
            }

            return {
                width: pos.width,
                height: pos.height
            };
        }

        function processCellText(cellNode, layer, cellX, cellY, cellWidth, cellHeight, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const txBodyNode = cellNode.getElementsByTagNameNS(DML_NS, 'txBody')[0];
            if (!txBodyNode) return;

            // Handle vertical alignment
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];
            const vAlign = tcPrNode ? tcPrNode.getAttribute('anchor') : 't'; // t, ctr, b

            const paragraphs = Array.from(txBodyNode.getElementsByTagNameNS(DML_NS, 'p'));
            if (paragraphs.length === 0) return;

            const textNodes = [];
            let totalTextHeight = 0;
            const PADDING = 5; // 5px padding inside cell

            for (const pNode of paragraphs) {
                // Simplified text parsing for now. A full implementation would parse
                // run properties (<rPr>) for detailed styling.
                const pText = pNode.textContent.trim();
                if (pText) {
                    const textEl = new Konva.Text({
                        text: pText,
                        fontSize: 14, // TODO: Inherit from style
                        fontFamily: 'Arial', // TODO: Inherit from style
                        fill: '#000000', // TODO: Inherit from style
                        width: cellWidth - (PADDING * 2),
                        lineHeight: 1.2,
                    });
                    textNodes.push(textEl);
                    totalTextHeight += textEl.height();
                }
            }

            let startY;
            if (vAlign === 'b') {
                startY = cellHeight - totalTextHeight - PADDING;
            } else if (vAlign === 'ctr') {
                startY = (cellHeight - totalTextHeight) / 2;
            } else { // 't' or default
                startY = PADDING;
            }

            const textGroup = new Konva.Group({
                x: cellX + PADDING,
                y: cellY, // Y will be handled per-node
                clip: { x: 0, y: 0, width: cellWidth, height: cellHeight },
            });
            layer.add(textGroup);

            let currentY = startY;
            textNodes.forEach(textNode => {
                textNode.y(currentY);
                textGroup.add(textNode);
                currentY += textNode.height();
            });
        }

        async function processPicture(picNode, layer, imageMap, parentXfrm, layoutPlaceholders) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            let pos = null;

            // 1. Try to get transform from the picture element itself
            const spPrNode = picNode.getElementsByTagNameNS(PML_NS, 'spPr')[0];
            const xfrmNode = spPrNode ? spPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0] : null;

            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    pos = {
                        x: (parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL) + parentXfrm.x,
                        y: (parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL) + parentXfrm.y,
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                    };
                }
            } else {
                // 2. If no transform, look for a placeholder and get transform from layout
                const nvPicPrNode = picNode.getElementsByTagNameNS(PML_NS, 'nvPicPr')[0];
                const nvPrNode = nvPicPrNode ? nvPicPrNode.getElementsByTagNameNS(PML_NS, 'nvPr')[0] : null;
                const phNode = nvPrNode ? nvPrNode.getElementsByTagNameNS(PML_NS, 'ph')[0] : null;

                if (phNode && layoutPlaceholders) {
                    const phType = phNode.getAttribute('type');
                    const phIdx = phNode.getAttribute('idx');
                    const phKey = phIdx ? `idx_${phIdx}` : phType;

                    if (layoutPlaceholders[phKey]) {
                        pos = { ...layoutPlaceholders[phKey].pos }; // Clone from layout
                        pos.x += parentXfrm.x;
                        pos.y += parentXfrm.y;
                    }
                }
            }

            if (!pos) return { width: 0, height: 0 };

            // 3. Get image relationship ID from blipFill -> blip
            const blipFillNode = picNode.getElementsByTagNameNS(PML_NS, 'blipFill')[0];
            if (!blipFillNode) return { width: 0, height: 0 };

            const blipNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
            if (!blipNode) return { width: 0, height: 0 };

            const relId = blipNode.getAttribute('r:embed');
            if (!relId || !imageMap[relId]) return { width: 0, height: 0 };

            // 4. Create Konva Image
            try {
                const imageObj = await createImage(imageMap[relId]);
                const konvaImage = new Konva.Image({
                    x: pos.x,
                    y: pos.y,
                    image: imageObj,
                    width: pos.width,
                    height: pos.height,
                });
                layer.add(konvaImage);
            } catch (e) {
                console.error("Error creating image", e);
            }

            return { width: pos.width, height: pos.height };
        }

        async function renderSlide( slideXml, slideContainer, layoutPlaceholders, slideNum, slideSize, defaultTextStyles, imageMap, slideContext, finalBg, showMasterShapes, masterStaticShapes, layoutStaticShapes, slideRels, entriesMap ) {
            activeCharts = []; // Clear previously rendered charts
            const xmlDoc = parseXmlString(slideXml, `slide number ${slideNum}`);
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const listCounters = {};
            const stage = new Konva.Stage({
                container: slideContainer,
                width: slideSize.width,
                height: slideSize.height,
            });

            const bgLayer = new Konva.Layer();
            stage.add(bgLayer);
            if (finalBg) {
                if (finalBg.type === 'color') {
                    const bgRect = new Konva.Rect({
                        x: 0,
                        y: 0,
                        width: slideSize.width,
                        height: slideSize.height,
                        fill: finalBg.value,
                    });
                    bgLayer.add(bgRect);
                } else if (finalBg.type === 'image' && finalBg.relId && imageMap[finalBg.relId]) {
                    const imageObj = await createImage(imageMap[finalBg.relId]);
                    const bgImage = new Konva.Image({
                        x: 0,
                        y: 0,
                        image: imageObj,
                        width: slideSize.width,
                        height: slideSize.height,
                    });
                    bgLayer.add(bgImage);
                }
            }

            const mainLayer = new Konva.Layer();
            stage.add(mainLayer);

            if (showMasterShapes) {
                if (masterStaticShapes) {
                    for (const shape of masterStaticShapes) {
                        await processShape(shape, mainLayer, layoutPlaceholders, slideContext, imageMap, listCounters, { x: 0, y: 0 }, defaultTextStyles);
                    }
                }
                 if (layoutStaticShapes) {
                    for (const shape of layoutStaticShapes) {
                        await processShape(shape, mainLayer, layoutPlaceholders, slideContext, imageMap, listCounters, { x: 0, y: 0 }, defaultTextStyles);
                    }
                }
            }

            const spTreeNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'spTree')[0];
            if (spTreeNode) {
                for (const element of spTreeNode.children) {
                    const tagName = element.localName;
                    if (tagName === 'sp' || tagName === 'cxnSp') {
                        await processShape(element, mainLayer, layoutPlaceholders, slideContext, imageMap, listCounters, { x: 0, y: 0 }, defaultTextStyles);
                    } else if (tagName === 'grpSp') {
                        await processGroupShape(element, mainLayer, layoutPlaceholders, slideContext, imageMap, listCounters, { x: 0, y: 0 }, defaultTextStyles);
                    } else if (tagName === 'graphicFrame') {
                        const graphicData = element.getElementsByTagNameNS(DML_NS, 'graphicData')[0];
                        if (graphicData && graphicData.getAttribute('uri') === 'http://schemas.openxmlformats.org/drawingml/2006/table') {
                            await processTable(element, mainLayer, slideContext);
                        } else if (graphicData && graphicData.getAttribute('uri') === 'http://schemas.openxmlformats.org/drawingml/2006/chart') {
                            const chartRelId = graphicData.getElementsByTagNameNS("http://schemas.openxmlformats.org/drawingml/2006/chart", "chart")[0].getAttribute("r:id");
                            if (chartRelId && slideRels[chartRelId]) {
                                const chartPath = resolvePath('ppt/slides', slideRels[chartRelId].target);
                                console.log(`Found chart with relId ${chartRelId}, path: ${chartPath}`);
                                const chartXml = await getNormalizedXmlString(entriesMap, chartPath);
                                if (chartXml) {
                                    const chartData = parseChart(chartXml);
                                    await renderChart(element, mainLayer, chartData);
                                }
                            }
                        }
                    } else if (tagName === 'pic') {
                        await processPicture(element, mainLayer, imageMap, { x: 0, y: 0 }, layoutPlaceholders);
                    }
                }
            }

            const resizeStage = () => {
                const containerWidth = slideContainer.offsetWidth;
                if (containerWidth > 0) {
                    const scale = containerWidth / slideSize.width;
                    stage.scale({ x: scale, y: scale });
                    stage.width(slideSize.width * scale);
                    stage.height(slideSize.height * scale);

                    for (const chart of activeCharts) {
                        chart.container.style.left = `${chart.pos.x * scale}px`;
                        chart.container.style.top = `${chart.pos.y * scale}px`;
                        chart.container.style.width = `${chart.pos.width * scale}px`;
                        chart.container.style.height = `${chart.pos.height * scale}px`;
                    }
                }
            };

            resizeStage();

            const observer = new ResizeObserver(resizeStage);
            observer.observe(slideContainer);
        }

        function parseChart(chartXml) {
            const xmlDoc = parseXmlString(chartXml, "chart");
            const C_NS = "http://schemas.openxmlformats.org/drawingml/2006/chart";

            const chartData = {
                type: null,
                title: null,
                labels: [],
                datasets: []
            };

            const titleNode = xmlDoc.getElementsByTagNameNS(C_NS, 'title')[0];
            if (titleNode) {
                chartData.title = titleNode.textContent.trim();
            }

            const plotAreaNode = xmlDoc.getElementsByTagNameNS(C_NS, 'plotArea')[0];
            if (!plotAreaNode) return null;

            const chartTypeMap = {
                'barChart': 'bar',
                'lineChart': 'line',
                'pieChart': 'pie',
                // TODO: Add other chart types
            };

            let chartTypeNode;
            for (const type in chartTypeMap) {
                chartTypeNode = plotAreaNode.getElementsByTagNameNS(C_NS, type)[0];
                if (chartTypeNode) {
                    chartData.type = chartTypeMap[type];
                    break;
                }
            }

            if (!chartTypeNode) return null;

            const serNodes = chartTypeNode.getElementsByTagNameNS(C_NS, 'ser');
            for (const serNode of serNodes) {
                const dataset = {
                    label: '',
                    data: []
                };

                const txValNode = serNode.getElementsByTagNameNS(C_NS, 'tx')[0]?.getElementsByTagNameNS(C_NS, 'v')[0];
                if (txValNode) {
                    dataset.label = txValNode.textContent.trim();
                }

                const catNode = serNode.getElementsByTagNameNS(C_NS, 'cat')[0];
                if (catNode) {
                    const strRefNode = catNode.getElementsByTagNameNS(C_NS, 'strRef')[0];
                    if (strRefNode) {
                        const ptNodes = strRefNode.getElementsByTagNameNS(C_NS, 'pt');
                        chartData.labels = Array.from(ptNodes).map(pt => pt.textContent.trim());
                    }
                }

                const valNode = serNode.getElementsByTagNameNS(C_NS, 'val')[0];
                if (valNode) {
                    const numRefNode = valNode.getElementsByTagNameNS(C_NS, 'numRef')[0];
                    if (numRefNode) {
                        const ptNodes = numRefNode.getElementsByTagNameNS(C_NS, 'pt');
                        dataset.data = Array.from(ptNodes).map(pt => parseFloat(pt.textContent.trim()));
                    }
                }

                chartData.datasets.push(dataset);
            }

            return chartData;
        }

        async function renderChart(graphicFrame, layer, chartData) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const xfrmNode = graphicFrame.getElementsByTagNameNS(PML_NS, 'xfrm')[0];
            if (!xfrmNode) return;

            const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
            const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
            if (!offNode || !extNode) return;

            const pos = {
                x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
            };

            // Since Konva doesn't directly support embedding charts, we create an
            // HTML overlay for the chart canvas.
            const chartContainer = document.createElement('div');
            chartContainer.style.position = 'absolute';
            // Defer positioning to the resizeStage function to handle scaling

            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);

            // The slide container is the Konva stage's parent. We need to append
            // our chart overlay to the same parent to make it appear on top.
            layer.getStage().container().appendChild(chartContainer);

            activeCharts.push({
                container: chartContainer,
                pos: pos
            });

            const ctx = canvas.getContext('2d');
            new Chart(ctx, {
                type: chartData.type,
                data: {
                    labels: chartData.labels,
                    datasets: chartData.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: !!chartData.title,
                            text: chartData.title
                        }
                    }
                }
            });
        }
    </script>
</body>

</html>