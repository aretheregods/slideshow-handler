<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Native PPTX Parser - Step 4</title>
    <style>
        /* General Body Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #f9fafb;
            color: #1f2937;
            margin: 0;
            padding: 0;
            line-height: 1.5;
        }

        /* Container and Layout */
        .container {
            width: 100%;
            max-width: 56rem;
            /* 896px */
            margin-left: auto;
            margin-right: auto;
            padding: 2rem 1rem;
        }

        /* Header and Typography */
        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2.25rem;
            /* 36px */
            font-weight: 700;
            color: #111827;
        }

        header p {
            margin-top: 0.5rem;
            font-size: 1.125rem;
            /* 18px */
            color: #4b5563;
        }

        /* Card-like Sections */
        .card {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .card h2 {
            font-size: 1.5rem;
            /* 24px */
            font-weight: 600;
            margin-bottom: 1rem;
        }

        /* File Upload Area */
        .file-upload-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 12rem;
            /* 192px */
            border: 2px dashed #d1d5db;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #f9fafb;
            transition: background-color 0.2s ease-in-out;
        }

        .file-upload-label:hover {
            background-color: #f3f4f6;
        }

        #pptx-file {
            display: none;
        }

        #file-info {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.875rem;
            /* 14px */
            color: #6b7280;
        }

        /* --- Slide Viewer & Debug Styling --- */
        .slide-viewer {
            width: 100%;
            height: auto;
            border: 1px solid #e5e7eb;
            background-color: #fff;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin: 2rem auto;
            position: relative;
        }

        .slide-viewer svg {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
            /* For visualization */
        }

        #debug-output {
            margin-top: 1.5rem;
            background-color: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: "SF Mono", "Fira Code", "Fira Mono", "Roboto Mono", monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #debug-output h3 {
            margin-top: 0;
            color: #9ca3af;
            font-weight: 500;
        }

        /* Loading Spinner */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>Native PPTX Parser</h1>
            <p><strong>Step 4:</strong> Integrating Slide Layouts for correct positioning.</p>
        </header>

        <div>
            <!-- File Upload Section -->
            <div class="card">
                <h2>1. Upload Presentation</h2>
                <div>
                    <label for="pptx-file" class="file-upload-label">
                        <!-- SVG icon for upload -->
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                            </path>
                        </svg>
                        <p><span>Click to upload</span> or drag and drop</p>
                        <p>PPTX file</p>
                        <input id="pptx-file" type="file" accept=".pptx" />
                    </label>
                </div>
                <div id="file-info"></div>
            </div>

            <!-- Slide Render Section -->
            <div id="output-container" style="display: none;">
                <div id="loading-indicator" style="text-align: center; padding: 2rem;">
                    <!-- SVG spinner -->
                    <svg aria-hidden="true"
                        style="display: inline; width: 2rem; height: 2rem; margin-right: 0.5rem; color: #e5e7eb; animation: spin 1s linear infinite;"
                        viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
                            fill="currentColor" />
                        <path
                            d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
                            fill="#4f46e5" />
                    </svg>
                    <p>Rendering slides...</p>
                </div>
                <div id="slide-viewer-container"></div>
                <div id="debug-output" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Main application script -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.2.0/dist/chart.umd.js"></script>
    <script type="module">
        import {
            BlobReader,
            BlobWriter,
            TextReader,
            TextWriter,
            ZipReader,
            ZipWriter,
        } from "https://deno.land/x/zipjs/index.js";
        import Konva from 'https://cdn.jsdelivr.net/npm/konva@9.3.6/+esm';
        import { decompose, getTransformationMatrix } from './src/utils/shape-builder.js';
        import * as Matrix from './src/utils/matrix.js';

        const EMU_PER_PIXEL = 12700; // Standard conversion for 96 DPI
        const PT_TO_PX = .975; // Adjusted conversion for web rendering (90/72)
        const LINE_HEIGHT = 24; // A default line height in pixels for SVG text
        const INDENTATION_AMOUNT = 30; // Pixels per indentation level
        const BULLET_OFFSET = 20; // Space between bullet and text

        const fileInput = document.getElementById( 'pptx-file' );
        const fileInfo = document.getElementById( 'file-info' );
        const outputContainer = document.getElementById( 'output-container' );
        let activeCharts = [];
        const slideViewerContainer = document.getElementById( 'slide-viewer-container' );
        const loadingIndicator = document.getElementById( 'loading-indicator' );
        const debugOutput = document.getElementById( 'debug-output' );

        function resolvePath(baseDir, target) {
            // Normalize backslashes to forward slashes for cross-platform compatibility.
            const normalizedTarget = target.replace(/\\/g, '/');

            // If target is an absolute path (starts with '/'), it's relative to the zip root.
            if (normalizedTarget.startsWith('/')) {
                // Just remove the leading slash and return.
                return normalizedTarget.substring(1);
            }
            // Otherwise, resolve it relative to the baseDir.
            const path = baseDir + '/' + normalizedTarget;
            const parts = path.split('/');
            const resolved = [];
            for (const part of parts) {
                if (part === '..') {
                    resolved.pop();
                } else if (part !== '.' && part !== '') {
                    resolved.push(part);
                }
            }
            return resolved.join('/');
        }
        function parseXmlString(xmlString, identifier) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            const errorNode = xmlDoc.querySelector("parsererror");
            if (errorNode) {
                console.error(`XML Parsing Error in ${identifier}:`, errorNode.innerHTML);
                console.log(`Problematic XML for ${identifier}:`, xmlString);
            }
            return xmlDoc;
        }

        async function getNormalizedXmlString(entriesMap, path) {
            const entry = entriesMap.get(path);
            if (!entry) return null;

            const writer = new TextWriter();
            let xmlString = await entry.getData(writer);

            // Strip BOM if present, as it can interfere with XML parsing on some platforms.
            if (xmlString.charCodeAt(0) === 0xFEFF) {
                xmlString = xmlString.substring(1);
            }

            // Normalize line endings to prevent cross-platform parsing issues.
            return xmlString.replace(/\\r\\n/g, '\n').replace(/\\r/g, '\n');
        }

        fileInput.addEventListener( 'change', async ( event ) => {
            const file = event.target.files[ 0 ];
            if ( !file ) return;

            fileInfo.textContent = `File selected: ${ file.name }`;
            outputContainer.style.display = 'block';
            slideViewerContainer.innerHTML = '';
            debugOutput.style.display = 'none';
            loadingIndicator.style.display = 'block';
            debugOutput.innerHTML = '';

            const zipReader = new ZipReader(new BlobReader(file));
            try {
                const entries = await zipReader.getEntries();
                const entriesMap = new Map(entries.map(entry => [entry.filename, entry]));

                const presRels = await getRelationships( entriesMap, "ppt/_rels/presentation.xml.rels" );
                const sortedPresRels = Object.values(presRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));

                let theme = null;
                const themeRel = sortedPresRels.find(rel => rel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme');
                if (themeRel) {
                    const themePath = resolvePath('ppt', themeRel.target);
                    const themeXml = await getNormalizedXmlString(entriesMap, themePath);
                    if (themeXml) theme = parseTheme(themeXml);
                }

                let tableStyles = {};
                const tableStylesRel = sortedPresRels.find(rel => rel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles');
                if (tableStylesRel) {
                    const tableStylesPath = resolvePath('ppt', tableStylesRel.target);
                    const tableStylesXml = await getNormalizedXmlString(entriesMap, tableStylesPath);
                    if (tableStylesXml) tableStyles = parseTableStyles(tableStylesXml);
                }

                const presentationXml = await getNormalizedXmlString(entriesMap, "ppt/presentation.xml");
                const slideIds = getSlideOrder( presentationXml );

                const slideSize = getSlideSize( presentationXml );

                if ( slideIds.length === 0 ) {
                    fileInfo.textContent = "No slides found in the presentation.";
                    return;
                }

                let allSlidesDebugText = '<h3>Raw Parsed Content:</h3>';
                let totalElementsFound = 0;

                for ( let i = 0; i < slideIds.length; i++ ) {
                    const slideNum = i + 1;
                    const slideId = slideIds[ i ];
                    const slideRel = presRels[ slideId ];
                    if ( !slideRel ) continue;

                    const slidePath = resolvePath( 'ppt', slideRel.target );
                    const slideRelsPath = `ppt/slides/_rels/${ slidePath.split( '/' ).pop() }.rels`;
                    const slideRels = await getRelationships( entriesMap, slideRelsPath );
                    const sortedSlideRels = Object.values(slideRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));

                    const imageMap = {};
                    await populateImageMap(imageMap, slideRels, 'ppt/slides', entriesMap);


                    const slideContext = {
                        theme: theme,
                        colorMap: {},
                        tableStyles: tableStyles,
                    };

                    const layoutRel = sortedSlideRels.find( r => r.type.endsWith( '/slideLayout' ) );

                    let masterPlaceholders = {};
                    let layoutPlaceholders = {};
                    let defaultTextStyles = {};
                    let masterXml, layoutXml;

                    let masterStaticShapes = [], layoutStaticShapes = [];
                    if ( layoutRel ) {
                        const layoutPath = resolvePath('ppt/slides', layoutRel.target);
                        const layoutRelsPath = `ppt/slideLayouts/_rels/${ layoutPath.split( '/' ).pop() }.rels`;
                        const layoutRels = await getRelationships( entriesMap, layoutRelsPath );
                        await populateImageMap(imageMap, layoutRels, 'ppt/slideLayouts', entriesMap);
                        const sortedLayoutRels = Object.values(layoutRels).sort((a, b) => a.id.localeCompare(b.id, undefined, { numeric: true }));
                        const masterRel = sortedLayoutRels.find( r => r.type.endsWith( '/slideMaster' ) );

                        let masterData;
                        if ( masterRel ) {
                            const masterPath = resolvePath('ppt/slideLayouts', masterRel.target);
                            const masterRelsPath = `ppt/slideMasters/_rels/${masterPath.split('/').pop()}.rels`;
                            const masterRels = await getRelationships( entriesMap, masterRelsPath );
                            await populateImageMap(imageMap, masterRels, 'ppt/slideMasters', entriesMap);

                            masterXml = await getNormalizedXmlString(entriesMap, masterPath);
                            if (masterXml) {
                                masterData = parseMasterOrLayout( masterXml, theme, null, false );
                            }
                            masterPlaceholders = masterData.placeholders;
                            masterStaticShapes = masterData.staticShapes;
                            defaultTextStyles = masterData.defaultTextStyles;
                            slideContext.colorMap = masterData.colorMap;
                        }

                        let layoutData;
                        layoutXml = await getNormalizedXmlString(entriesMap, layoutPath);
                        if (layoutXml) {
                            layoutData = parseMasterOrLayout( layoutXml, theme, masterData ? masterData.colorMap : null, true );
                        }
                        layoutPlaceholders = layoutData.placeholders;
                        layoutStaticShapes = layoutData.staticShapes;
                        if (layoutData.colorMapOverride) {
                            slideContext.colorMap = { ...slideContext.colorMap, ...layoutData.colorMapOverride };
                        }
                    }

                    const slideXml = await getNormalizedXmlString(entriesMap, slidePath);

                    const slideXmlDoc = parseXmlString(slideXml, `slide ${slideId}`);
                    const layoutXmlDoc = layoutXml ? parseXmlString(layoutXml, `layout for slide ${slideId}`) : null;
                    const masterXmlDoc = masterXml ? parseXmlString(masterXml, `master for slide ${slideId}`) : null;

                    const sldNode = slideXmlDoc.getElementsByTagNameNS("http://schemas.openxmlformats.org/presentationml/2006/main", 'sld')[0];
                    const showMasterShapes = !sldNode || sldNode.getAttribute('showMasterSp') !== '0';

                    const slideBg = parseBackground(slideXmlDoc, slideContext);
                    const layoutBg = layoutXmlDoc ? parseBackground(layoutXmlDoc, slideContext) : null;
                    const masterBg = masterXmlDoc ? parseBackground(masterXmlDoc, slideContext) : null;
                    const finalBg = slideBg || layoutBg || masterBg;

                    const slideContainer = document.createElement( 'div' );
                    slideContainer.className = 'slide-viewer';
                    slideContainer.id = `slide-${ i + 1 }`;
                    slideContainer.style.aspectRatio = `${slideSize.width} / ${slideSize.height}`;
                    slideViewerContainer.appendChild( slideContainer );

                    // The renderSlide function now handles its own scaling.
                    await renderSlide( slideXml, slideContainer, masterPlaceholders, layoutPlaceholders, slideNum, slideSize, defaultTextStyles, imageMap, slideContext, finalBg, showMasterShapes, masterStaticShapes, layoutStaticShapes, slideRels, entriesMap );
                }

            } catch ( error ) {
                console.error( 'Error parsing the presentation:', error );
                fileInfo.textContent = `Error: Could not parse presentation. ${ error.message }`;
            } finally {
                await zipReader.close();
                loadingIndicator.style.display = 'none';
            }
        } );

        async function getRelationships(entriesMap, path) {
            let xmlString = await getNormalizedXmlString(entriesMap, path);
            if (!xmlString) return {};

            const rels = {};
            // Use regex to parse relationships to be resilient to XML parsing errors.
            const relRegex = /<Relationship\s+([^>]+)\/?>/g;
            const attrRegex = /(\w+)="([^"]+)"/g;

            let match;
            while ((match = relRegex.exec(xmlString)) !== null) {
                const attrs = {};
                const attributesString = match[1];
                for (const attrMatch of attributesString.matchAll(attrRegex)) {
                    attrs[attrMatch[1]] = attrMatch[2];
                }

                if (attrs.Id && attrs.Type && attrs.Target) {
                    rels[attrs.Id] = {
                        id: attrs.Id,
                        type: attrs.Type,
                        target: attrs.Target
                    };
                }
            }
            return rels;
        }

        function getSlideOrder(xmlString) {
            const ids = [];
            const regex = /<[^>:]*:sldId[^>]+r:id="([^"]+)"/g;
            let match;
            while ((match = regex.exec(xmlString)) !== null) {
                ids.push(match[1]);
            }
            return ids;
        }

        function getSlideSize(xmlString) {
            // Two-step regex for robustness: first find the tag, then find the attributes within it.
            const sldSzTagMatch = xmlString.match(/<[^>:]*:sldSz\s+([^>]+)\/?>/);
            if (sldSzTagMatch) {
                const attrs = sldSzTagMatch[1];
                const cxMatch = attrs.match(/cx="([^"]+)"/);
                const cyMatch = attrs.match(/cy="([^"]+)"/);
                if (cxMatch && cyMatch) {
                    const cx = parseInt(cxMatch[1]);
                    const cy = parseInt(cyMatch[1]);
                    return { width: cx / EMU_PER_PIXEL, height: cy / EMU_PER_PIXEL };
                }
            }
            return { width: 960, height: 720 }; // Default size
        }

        function resolveFontFamily(finalRunProps, phType, slideContext) {
            const fontAlias = finalRunProps.font;
            const theme = slideContext.theme;

            if (fontAlias) {
                if (fontAlias === '+mj-lt') {
                    return theme?.fontScheme?.major || 'Arial';
                }
                if (fontAlias === '+mn-lt') {
                    return theme?.fontScheme?.minor || 'Arial';
                }
                return fontAlias; // It's a specific font like 'Calibri'
            }

            // No font in run, so fallback to placeholder type
            if (phType === 'title' || phType === 'ctrTitle' || phType === 'subTitle') {
                return theme?.fontScheme?.major || 'Arial';
            }

            return theme?.fontScheme?.minor || 'Arial';
        }

        function layoutParagraphs(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const paddedPos = {
                x: pos.x + (bodyPr.lIns || 0),
                y: pos.y + (bodyPr.tIns || 0),
                width: pos.width - (bodyPr.lIns || 0) - (bodyPr.rIns || 0),
                height: pos.height - (bodyPr.tIns || 0) - (bodyPr.bIns || 0),
            };

            const lines = [];
            let currentY = 0; // This will track the Y position for the start of each line.

            for (const pNode of paragraphs) {
                const pPrNode = pNode.getElementsByTagNameNS(DML_NS, 'pPr')[0];
                const level = pPrNode ? parseInt(pPrNode.getAttribute('lvl') || '0') : 0;
                let defaultStyle = defaultTextStyles.other;
                if (phType === 'title' || phType === 'ctrTitle' || phType === 'subTitle') defaultStyle = defaultTextStyles.title;
                else if (phType === 'body') defaultStyle = defaultTextStyles.body;

                const defaultLevelProps = (defaultStyle && defaultStyle[level]) ? defaultStyle[level] : {};

                const masterPh = masterPlaceholders ? masterPlaceholders[phKey] : null;
                let masterListStyle = (masterPh?.listStyle?.[level]) || {};
                if (masterPh && masterPh.type && phType && masterPh.type !== phType) {
                    masterListStyle = {};
                }

                const layoutPh = layoutPlaceholders ? layoutPlaceholders[phKey] : null;
                let layoutListStyle = (layoutPh?.listStyle?.[level]) || {};
                if (layoutPh && layoutPh.type && phType && layoutPh.type !== phType) {
                    layoutListStyle = {};
                }
                const slideLevelProps = parseParagraphProperties(pPrNode) || { bullet: {}, defRPr: {} };

                const finalProps = {
                    level,
                    ...defaultLevelProps,
                    ...masterListStyle,
                    ...layoutListStyle,
                    ...slideLevelProps,
                    bullet: { ...defaultLevelProps.bullet, ...masterListStyle.bullet, ...layoutListStyle.bullet, ...slideLevelProps.bullet },
                    defRPr: { ...defaultLevelProps.defRPr, ...masterListStyle.defRPr, ...layoutListStyle.defRPr, ...slideLevelProps.defRPr }
                };

                const indent = finalProps.indent || (level * INDENTATION_AMOUNT);
                const bulletOffset = (finalProps.bullet.type && finalProps.bullet.type !== 'none') ? BULLET_OFFSET : 0;
                const effectiveWidth = paddedPos.width - indent - bulletOffset;

                let currentLine = { runs: [], width: 0, height: 0, paragraphProps: finalProps, startY: currentY };
                let isFirstLineOfParagraph = true;

                const pushCurrentLine = () => {
                    if (currentLine.runs.length > 0) {
                        currentLine.isFirstLineOfParagraph = isFirstLineOfParagraph;
                        lines.push(currentLine);
                        currentY += currentLine.height || LINE_HEIGHT;
                        isFirstLineOfParagraph = false;
                    }
                    currentLine = { runs: [], width: 0, height: 0, paragraphProps: finalProps, startY: currentY };
                };

                const runsAndBreaks = Array.from(pNode.childNodes).filter(n => ['r', 'fld', 'br'].includes(n.localName));

                for (const childNode of runsAndBreaks) {
                    if (childNode.localName === 'br') {
                        pushCurrentLine();
                        continue;
                    }

                    const text = childNode.textContent;
                    if (!text) continue;

                    const rPr = childNode.getElementsByTagNameNS(DML_NS, 'rPr')[0];
                    const finalRunProps = { ...finalProps.defRPr };
                    if (rPr) {
                        if (rPr.getAttribute('sz')) finalRunProps.size = (parseInt(rPr.getAttribute('sz')) / 100) * PT_TO_PX;
                        if (rPr.getAttribute('b') === '1') finalRunProps.bold = true; else if (rPr.getAttribute('b') === '0') finalRunProps.bold = false;
                        if (rPr.getAttribute('i') === '1') finalRunProps.italic = true; else if (rPr.getAttribute('i') === '0') finalRunProps.italic = false;
                        const solidFill = rPr.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                        if (solidFill) finalRunProps.color = parseColor(solidFill);
                        const latinFontNode = rPr.getElementsByTagNameNS(DML_NS, 'latin')[0];
                        if (latinFontNode && latinFontNode.getAttribute('typeface')) finalRunProps.font = latinFontNode.getAttribute('typeface');
                    }

                    const textColor = resolveColor(finalRunProps.color, slideContext) || '#000000';
                    const fontSize = finalRunProps.size || (18 * PT_TO_PX);
                    const fontStyle = finalRunProps.bold && finalRunProps.italic ? 'bold italic' : finalRunProps.bold ? 'bold' : finalRunProps.italic ? 'italic' : 'normal';
                    const fontFamily = resolveFontFamily(finalRunProps, phType, slideContext);

                    const measurer = new Konva.Text({ fontSize, fontFamily, fontStyle });
                    const words = text.split(/(\s+)/); // Split on whitespace but keep it

                    for (const word of words) {
                        if (!word) continue;

                        const wordWidth = measurer.text(word).width();

                        if (currentLine.width + wordWidth > effectiveWidth && currentLine.runs.length > 0) {
                            pushCurrentLine();
                        }

                        const wordEl = new Konva.Text({ text: word, fontSize, fontFamily, fontStyle, fill: textColor });
                        currentLine.runs.push(wordEl);
                        currentLine.width += wordWidth;
                        currentLine.height = Math.max(currentLine.height, wordEl.height());
                    }
                }
                pushCurrentLine(); // Push the last line of the paragraph
            }

            const totalHeight = currentY;
            for(const line of lines) {
                const align = line.paragraphProps.align || 'l';
                const level = line.paragraphProps.level || 0;
                const indent = line.paragraphProps.indent || (level * INDENTATION_AMOUNT);
                const bulletOffset = (line.paragraphProps.bullet.type && line.paragraphProps.bullet.type !== 'none') ? BULLET_OFFSET : 0;
                const effectiveWidth = paddedPos.width - indent - bulletOffset;

                let lineXOffset = 0;
                if (align === 'ctr') {
                    lineXOffset = (effectiveWidth - line.width) / 2;
                } else if (align === 'r') {
                    lineXOffset = effectiveWidth - line.width;
                }
                line.x = paddedPos.x + indent + bulletOffset + lineXOffset;
            }

            return { totalHeight, lines };
        }

        function getAutoNumberingChar(scheme, number) {
            switch (scheme) {
                case 'alphaLcParenBoth': return `(${String.fromCharCode(96 + number)})`;
                case 'alphaLcParenR': return `${String.fromCharCode(96 + number)})`;
                case 'alphaLcPeriod': return `${String.fromCharCode(96 + number)}.`;
                case 'alphaUcParenBoth': return `(${String.fromCharCode(64 + number)})`;
                case 'alphaUcParenR': return `${String.fromCharCode(64 + number)})`;
                case 'alphaUcPeriod': return `${String.fromCharCode(64 + number)}.`;
                case 'arabicParenBoth': return `(${number})`;
                case 'arabicParenR': return `${number})`;
                case 'arabicPeriod': return `${number}.`;
                case 'arabicPlain': return `${number}`;
                // TODO: Implement Roman numeral conversion
                case 'romanLcParenBoth': return `(i)`;
                case 'romanLcParenR': return `i)`;
                case 'romanLcPeriod': return `i.`;
                case 'romanUcParenBoth': return `(I)`;
                case 'romanUcParenR': return `I)`;
                case 'romanUcPeriod': return `I.`;
                default: return `${number}.`;
            }
        }

        function createImage(url) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = url;
            });
        }

        async function populateImageMap(imageMap, rels, baseDir, entriesMap) {
            const imageRels = Object.values(rels).filter(rel => rel.type.endsWith('/image'));
            for (const rel of imageRels) {
                // Do not overwrite an image that has already been loaded from a more specific source (e.g., slide vs layout)
                if (imageMap[rel.id]) {
                    continue;
                }

                const imagePath = resolvePath(baseDir, rel.target);
                const imageEntry = entriesMap.get(imagePath);
                if (imageEntry) {
                    try {
                        const writer = new BlobWriter();
                        const imageBlob = await imageEntry.getData(writer);
                        const reader = new FileReader();
                        const imageData = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result.split(',')[1]);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        imageMap[rel.id] = `data:image/png;base64,${imageData}`;
                    } catch (e) {
                        console.error(`Failed to load image data for relId ${rel.id} at path ${imagePath}`, e);
                    }
                } else {
                    console.warn(`Image relationship '${rel.id}' points to a non-existent target: ${rel.target} (resolved to ${imagePath})`);
                }
            }
        }

        function parseTheme(themeXml) {
            const xmlDoc = parseXmlString(themeXml, "theme");
            const theme = {
                colorScheme: {},
                fontScheme: {},
                formatScheme: {
                    fills: [],
                    lines: [],
                    effects: [],
                    bgFills: [],
                },
            };

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const clrSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'clrScheme')[0];
            if (clrSchemeNode) {
                for (const child of clrSchemeNode.children) {
                    const colorName = child.localName;
                    const srgbClrNode = child.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
                    if (srgbClrNode) {
                        theme.colorScheme[colorName] = `#${srgbClrNode.getAttribute('val')}`;
                    }
                    const sysClrNode = child.getElementsByTagNameNS(DML_NS, 'sysClr')[0];
                    if (sysClrNode) {
                        const lastColor = sysClrNode.getAttribute('lastClr');
                        if (lastColor) {
                            // Use lastClr as a fallback, it's often more reliable
                            theme.colorScheme[colorName] = `#${lastColor}`;
                        }
                        // If no lastClr, we don't set a color, letting it fall back to default.
                    }
                }
            }

            const fontSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'fontScheme')[0];
            if (fontSchemeNode) {
                const majorFontNode = fontSchemeNode.getElementsByTagNameNS(DML_NS, 'majorFont')[0];
                if (majorFontNode) {
                    const latinFontNode = majorFontNode.getElementsByTagNameNS(DML_NS, 'latin')[0];
                    if (latinFontNode) {
                        theme.fontScheme.major = latinFontNode.getAttribute('typeface');
                    }
                }
                const minorFontNode = fontSchemeNode.getElementsByTagNameNS(DML_NS, 'minorFont')[0];
                if (minorFontNode) {
                    const latinFontNode = minorFontNode.getElementsByTagNameNS(DML_NS, 'latin')[0];
                    if (latinFontNode) {
                        theme.fontScheme.minor = latinFontNode.getAttribute('typeface');
                    }
                }
            }

            const fmtSchemeNode = xmlDoc.getElementsByTagNameNS(DML_NS, 'fmtScheme')[0];
            if (fmtSchemeNode) {
                const fillStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'fillStyleLst')[0];
                if (fillStyleLstNode) {
                    for (const fillNode of fillStyleLstNode.children) {
                        if (fillNode.localName === 'solidFill') {
                            const colorObj = parseColor(fillNode);
                            theme.formatScheme.fills.push({ type: 'solid', color: colorObj });
                        } else if (fillNode.localName === 'gradFill') {
                            const gsLstNode = fillNode.getElementsByTagNameNS(DML_NS, 'gsLst')[0];
                            const stops = [];
                            if (gsLstNode) {
                                for (const gsNode of gsLstNode.children) {
                                    const pos = parseInt(gsNode.getAttribute('pos')) / 1000; // Position is in 1000ths of a percent
                                    const colorObj = parseColor(gsNode);
                                    if (colorObj) {
                                        stops.push({ pos, color: colorObj });
                                    }
                                }
                            }
                            let angle = 0;
                            const linNode = fillNode.getElementsByTagNameNS(DML_NS, 'lin')[0];
                            if (linNode) {
                                angle = parseInt(linNode.getAttribute('ang')) / 60000; // Angle is in 60000ths of a degree
                            }
                            theme.formatScheme.fills.push({ type: 'gradient', stops, angle });
                        } else if (fillNode.localName === 'blipFill') {
                            const blipNode = fillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                            if (blipNode) {
                                const relId = blipNode.getAttribute('r:embed');
                                theme.formatScheme.fills.push({ type: 'image', relId: relId });
                            }
                        } else if (fillNode.localName === 'pattFill') {
                            const pattern = {
                                type: 'pattern',
                                pattern: fillNode.getAttribute('prst'),
                                fgColor: null,
                                bgColor: null,
                            };
                            const fgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'fgClr')[0];
                            if (fgClrNode) {
                                pattern.fgColor = parseColor(fgClrNode);
                            }
                            const bgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'bgClr')[0];
                            if (bgClrNode) {
                                pattern.bgColor = parseColor(bgClrNode);
                            }
                            theme.formatScheme.fills.push(pattern);
                        } else if (fillNode.localName === 'grpFill') {
                            theme.formatScheme.fills.push({ type: 'group' });
                        } else if (fillNode.localName === 'noFill') {
                            theme.formatScheme.fills.push({ type: 'none' });
                        } else {
                            theme.formatScheme.fills.push({ type: 'unsupported' });
                        }
                    }
                }

                const lnStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'lnStyleLst')[0];
                if (lnStyleLstNode) {
                    for (const lineNode of lnStyleLstNode.children) {
                        const width = parseInt(lineNode.getAttribute('w') || '9525');
                        const cap = lineNode.getAttribute('cap');
                        const cmpd = lineNode.getAttribute('cmpd');

                        const solidFillNode = lineNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                        if (solidFillNode) {
                            const colorObj = parseColor(solidFillNode);
                            theme.formatScheme.lines.push({ type: 'solid', color: colorObj, width: width / EMU_PER_PIXEL, cap, cmpd });
                        } else {
                            theme.formatScheme.lines.push({ type: 'unsupported' });
                        }
                    }
                }

                 const effectStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'effectStyleLst')[0];
                 if (effectStyleLstNode) {
                    // TODO: Implement effect parsing if needed
                 }

                const bgFillStyleLstNode = fmtSchemeNode.getElementsByTagNameNS(DML_NS, 'bgFillStyleLst')[0];
                if (bgFillStyleLstNode) {
                    for (const fillNode of bgFillStyleLstNode.children) {
                        if (fillNode.localName === 'solidFill') {
                            const colorObj = parseColor(fillNode);
                            theme.formatScheme.bgFills.push({ type: 'solid', color: colorObj });
                        } else if (fillNode.localName === 'gradFill') {
                            const gsLstNode = fillNode.getElementsByTagNameNS(DML_NS, 'gsLst')[0];
                            const stops = [];
                            if (gsLstNode) {
                                for (const gsNode of gsLstNode.children) {
                                    const pos = parseInt(gsNode.getAttribute('pos')) / 1000; // Position is in 1000ths of a percent
                                    const colorObj = parseColor(gsNode);
                                    if (colorObj) {
                                        stops.push({ pos, color: colorObj });
                                    }
                                }
                            }
                            let angle = 0;
                            const linNode = fillNode.getElementsByTagNameNS(DML_NS, 'lin')[0];
                            if (linNode) {
                                angle = parseInt(linNode.getAttribute('ang')) / 60000; // Angle is in 60000ths of a degree
                            }
                            theme.formatScheme.bgFills.push({ type: 'gradient', stops, angle });
                        } else if (fillNode.localName === 'blipFill') {
                            const blipNode = fillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                            if (blipNode) {
                                const relId = blipNode.getAttribute('r:embed');
                                theme.formatScheme.bgFills.push({ type: 'image', relId: relId });
                            }
                        } else if (fillNode.localName === 'pattFill') {
                            const pattern = {
                                type: 'pattern',
                                pattern: fillNode.getAttribute('prst'),
                                fgColor: null,
                                bgColor: null,
                            };
                            const fgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'fgClr')[0];
                            if (fgClrNode) {
                                pattern.fgColor = parseColor(fgClrNode);
                            }
                            const bgClrNode = fillNode.getElementsByTagNameNS(DML_NS, 'bgClr')[0];
                            if (bgClrNode) {
                                pattern.bgColor = parseColor(bgClrNode);
                            }
                            theme.formatScheme.bgFills.push(pattern);
                        } else if (fillNode.localName === 'grpFill') {
                            theme.formatScheme.bgFills.push({ type: 'group' });
                        } else if (fillNode.localName === 'noFill') {
                            theme.formatScheme.bgFills.push({ type: 'none' });
                        } else {
                            theme.formatScheme.bgFills.push({ type: 'unsupported' });
                        }
                    }
                }
            }

            return theme;
        }

        function parseColorMap(node) {
            const colorMap = {};
            if (node) {
                for (const { name, value } of node.attributes) {
                    colorMap[name] = value;
                }
            }
            return colorMap;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (Math.floor(r) << 16) + (Math.floor(g) << 8) + Math.floor(b)).toString(16).slice(1).toUpperCase();
        }

        function applyTint(hex, tint) {
            const base = hexToRgb(hex);
            if (!base) return hex;
            const amount = tint / 100000; // Tint is provided as e.g. 80000 for 80%
            const r = base.r * (1 - amount) + 255 * amount;
            const g = base.g * (1 - amount) + 255 * amount;
            const b = base.b * (1 - amount) + 255 * amount;
            return rgbToHex(r, g, b);
        }

        function applyShade(hex, shade) {
            const base = hexToRgb(hex);
            if (!base) return hex;
            const amount = shade / 100000; // Shade is provided as e.g. 80000 for 80%
            const r = base.r * (1 - amount);
            const g = base.g * (1 - amount);
            const b = base.b * (1 - amount);
            return rgbToHex(r, g, b);
        }

        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        function applyLuminance(hex, lumMod, lumOff) {
            const rgb = hexToRgb(hex);
            if (!rgb) return hex;

            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            let newL = hsl.l;

            if (lumMod) {
                newL *= (lumMod / 100000);
            }
            if (lumOff) {
                newL += (lumOff / 100000);
            }

            // Clamp luminance to the valid range [0, 1]
            newL = Math.max(0, Math.min(1, newL));

            const newRgb = hslToRgb(hsl.h, hsl.s, newL);
            return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
        }

        function parseColor(colorNode) {
            if (!colorNode) return null;

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const srgbClrNode = colorNode.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
            if (srgbClrNode) {
                const color = { srgb: `#${srgbClrNode.getAttribute('val')}` };
                const alphaNode = srgbClrNode.getElementsByTagNameNS(DML_NS, 'alpha')[0];
                if (alphaNode) color.alpha = parseInt(alphaNode.getAttribute('val'));
                return color;
            }

            const schemeClrNode = colorNode.getElementsByTagNameNS(DML_NS, 'schemeClr')[0];
            if (schemeClrNode) {
                const color = { scheme: schemeClrNode.getAttribute('val') };
                const tintNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'tint')[0];
                if (tintNode) color.tint = parseInt(tintNode.getAttribute('val'));

                const shadeNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'shade')[0];
                if (shadeNode) color.shade = parseInt(shadeNode.getAttribute('val'));

                const alphaNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'alpha')[0];
                if (alphaNode) color.alpha = parseInt(alphaNode.getAttribute('val'));

                const lumModNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'lumMod')[0];
                if (lumModNode) color.lumMod = parseInt(lumModNode.getAttribute('val'));

                const lumOffNode = schemeClrNode.getElementsByTagNameNS(DML_NS, 'lumOff')[0];
                if (lumOffNode) color.lumOff = parseInt(lumOffNode.getAttribute('val'));

                return color;
            }

            return null;
        }

        function resolveColor(colorObj, slideContext) {
            if (!colorObj || !slideContext.theme) {
                return null;
            }

            let hex;
            if (colorObj.srgb) {
                hex = colorObj.srgb;
            } else if (colorObj.scheme) {
                let themeColorName = slideContext.colorMap[colorObj.scheme] || colorObj.scheme;
                if (themeColorName === 'phClr') {
                    // phClr is context-dependent. For a robust default, we'll map it
                    // to a visible accent color like accent1.
                    themeColorName = 'accent1';
                }
                if (themeColorName && slideContext.theme.colorScheme[themeColorName]) {
                    hex = slideContext.theme.colorScheme[themeColorName];
                    if (colorObj.tint) hex = applyTint(hex, colorObj.tint);
                    if (colorObj.shade) hex = applyShade(hex, colorObj.shade);
                    if (colorObj.lumMod || colorObj.lumOff) hex = applyLuminance(hex, colorObj.lumMod, colorObj.lumOff);
                }
            }

            if (hex) {
                if (colorObj.alpha) {
                    const rgb = hexToRgb(hex);
                    if (rgb) {
                        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${colorObj.alpha / 100000})`;
                    }
                }
                return hex;
            }

            return null; // Return null if color can't be resolved
        }

        function parseTableStyles(xmlString) {
            const xmlDoc = parseXmlString(xmlString, "tableStyles");
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const styles = {};

            const tblStyleNodes = xmlDoc.getElementsByTagNameNS(DML_NS, 'tblStyle');

            for (const styleNode of tblStyleNodes) {
                const styleId = styleNode.getAttribute('styleId');
                const styleDef = {};

                const styleParts = ['wholeTbl', 'band1H', 'band2H', 'band1V', 'band2V', 'firstRow', 'lastRow', 'firstCol', 'lastCol', 'nwCell', 'neCell', 'swCell', 'seCell'];

                for (const partName of styleParts) {
                    const partNode = styleNode.getElementsByTagNameNS(DML_NS, partName)[0];
                    if (partNode) {
                        styleDef[partName] = parseStylePart(partNode);
                    }
                }
                // The ID in the slide is wrapped in braces, but not in the style definition
                styles[`{${styleId}}`] = styleDef;
            }

            return styles;
        }

        function parseStylePart(partNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const partDef = {
                tcStyle: {},
                tcTxStyle: {}
            };

            const tcStyleNode = partNode.getElementsByTagNameNS(DML_NS, 'tcStyle')[0];
            if (tcStyleNode) {
                const fillNode = tcStyleNode.getElementsByTagNameNS(DML_NS, 'fill')[0];
                if (fillNode) {
                    const solidFillNode = fillNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                    if (solidFillNode) {
                        partDef.tcStyle.fill = parseColor(solidFillNode);
                    }
                }

                const tcBdrNode = tcStyleNode.getElementsByTagNameNS(DML_NS, 'tcBdr')[0];
                if (tcBdrNode) {
                    partDef.tcStyle.borders = {};
                    const borderTypes = ['left', 'right', 'top', 'bottom'];
                    for (const type of borderTypes) {
                        const borderNode = tcBdrNode.getElementsByTagNameNS(DML_NS, type)[0];
                        if (borderNode) {
                            const lnNode = borderNode.getElementsByTagNameNS(DML_NS, 'ln')[0];
                            if (lnNode) {
                                const width = parseInt(lnNode.getAttribute('w') || '9525') / EMU_PER_PIXEL;
                                const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                                if (solidFillNode) {
                                    const colorObj = parseColor(solidFillNode);
                                    if (colorObj) {
                                        partDef.tcStyle.borders[type] = {
                                            width: width,
                                            color: colorObj
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }

            const tcTxStyleNode = partNode.getElementsByTagNameNS(DML_NS, 'tcTxStyle')[0];
            if (tcTxStyleNode) {
                // TODO: Parse text styles for tables (bold, italic, color, etc.)
            }

            return partDef;
        }

        function parseBackground(xmlDoc, slideContext) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const bgNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'bg')[0];
            if (!bgNode) return null;

            const bgPrNode = bgNode.getElementsByTagNameNS(PML_NS, 'bgPr')[0];
            if (bgPrNode) {
                const solidFillNode = bgPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                if (solidFillNode) {
                    const colorObj = parseColor(solidFillNode);
                    if (colorObj) {
                        return { type: 'color', value: resolveColor(colorObj, slideContext) };
                    }
                }

                const blipFillNode = bgPrNode.getElementsByTagNameNS(DML_NS, 'blipFill')[0];
                if (blipFillNode) {
                    const blipNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
                    if (blipNode) {
                        const relId = blipNode.getAttribute('r:embed');
                        return { type: 'image', relId: relId };
                    }
                }
            }

            return null;
        }

        function parseCustomGeometry(custGeomNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const pathLstNode = custGeomNode.getElementsByTagNameNS(DML_NS, 'pathLst')[0];
            if (!pathLstNode) return null;

            const pathNode = pathLstNode.getElementsByTagNameNS(DML_NS, 'path')[0];
            if (!pathNode) return null;

            const pathW = parseInt(pathNode.getAttribute('w'));
            const pathH = parseInt(pathNode.getAttribute('h'));
            const commands = [];

            for (const cmdNode of pathNode.children) {
                const cmd = cmdNode.localName;
                const ptNodes = cmdNode.getElementsByTagNameNS(DML_NS, 'pt');
                const points = Array.from(ptNodes).map(pt => ({
                    x: parseInt(pt.getAttribute('x')),
                    y: parseInt(pt.getAttribute('y')),
                }));

                // close doesn't have points, handle it separately
                if (cmd === 'close') {
                    commands.push({ cmd: 'close', points: [] });
                } else {
                    commands.push({ cmd, points });
                }
            }

            if (commands.length === 0) return null;

            return {
                commands: commands,
                w: pathW,
                h: pathH,
            };
        }

        function parseLineProperties(lnNode, slideContext) {
            if (!lnNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const noFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
            if (noFillNode) return null;

            const props = {
                width: parseInt(lnNode.getAttribute('w') || '9525') / EMU_PER_PIXEL,
                cap: lnNode.getAttribute('cap'), // rnd, sq, flat
                join: null // miter, round, bevel
            };

            const roundNode = lnNode.getElementsByTagNameNS(DML_NS, 'round')[0];
            if (roundNode) props.join = 'round';

            const bevelNode = lnNode.getElementsByTagNameNS(DML_NS, 'bevel')[0];
            if (bevelNode) props.join = 'bevel';

            const miterNode = lnNode.getElementsByTagNameNS(DML_NS, 'miter')[0];
            if (miterNode) props.join = 'miter';

            const prstDashNode = lnNode.getElementsByTagNameNS(DML_NS, 'prstDash')[0];
            if (prstDashNode) {
                const dashType = prstDashNode.getAttribute('val') || 'solid';
                switch (dashType) {
                    case 'solid':
                        props.dash = [];
                        break;
                    case 'dot':
                        props.dash = [1, 5];
                        break;
                    case 'dash':
                        props.dash = [10, 5];
                        break;
                    case 'lgDash':
                        props.dash = [20, 10];
                        break;
                    default:
                        props.dash = [];
                        break;
                }
            }

            const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
            if (solidFillNode) {
                props.color = resolveColor(parseColor(solidFillNode), slideContext);
            }

            return props;
        }

        function parseShapeProperties(shapeNode, slideContext, slideNum) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const spPrNode = shapeNode.getElementsByTagNameNS(PML_NS, 'spPr')[0];
            if (!spPrNode) return { fill: null, stroke: null, geometry: null, rawFillNode: null, rawStrokeNode: null };

            const properties = { fill: null, stroke: null, geometry: null, rawFillNode: null, rawStrokeNode: null };

            const prstGeomNode = spPrNode.getElementsByTagNameNS(DML_NS, 'prstGeom')[0];
            if (prstGeomNode) {
                properties.geometry = { type: 'preset', preset: prstGeomNode.getAttribute('prst') };
            }

            const custGeomNode = spPrNode.getElementsByTagNameNS(DML_NS, 'custGeom')[0];
            if (custGeomNode) {
                properties.geometry = { type: 'custom', path: parseCustomGeometry(custGeomNode) };
            }

            // --- Fill Parsing ---
            let fillNode = null;
            const fillTypes = ['solidFill', 'gradFill', 'noFill', 'blipFill', 'pattFill', 'grpFill'];
            for (const child of spPrNode.children) {
                if (fillTypes.includes(child.localName)) {
                    fillNode = child;
                    break;
                }
            }

            if (fillNode) {
                properties.rawFillNode = fillNode.outerHTML;
                if (fillNode.localName === 'noFill') {
                    properties.fill = 'none';
                } else if (fillNode.localName === 'solidFill') {
                    const colorObj = parseColor(fillNode);
                    if (colorObj) properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                } else if (fillNode.localName === 'gradFill') {
                    // Gradient parsing logic...
                }
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const fillRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'fillRef')[0];
                    if (fillRefNode) {
                        properties.rawFillNode = fillRefNode.outerHTML;
                        const idx = parseInt(fillRefNode.getAttribute('idx'));
                        const colorOverride = parseColor(fillRefNode);
                        if (idx > 0 && slideContext.theme.formatScheme.fills[idx - 1]) {
                            const themeFill = slideContext.theme.formatScheme.fills[idx - 1];
                            let colorObj = colorOverride || themeFill.color;
                            if (themeFill.type === 'solid') {
                                properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                            }
                        } else if (colorOverride) {
                            properties.fill = { type: 'solid', color: resolveColor(colorOverride, slideContext) };
                        }
                    }
                }
            }

            // --- Stroke Parsing ---
            const lnNode = spPrNode.getElementsByTagNameNS(DML_NS, 'ln')[0];
            if (lnNode) {
                properties.rawStrokeNode = lnNode.outerHTML;
                properties.stroke = parseLineProperties(lnNode, slideContext);
            } else {
                const styleNode = shapeNode.getElementsByTagNameNS(PML_NS, 'style')[0];
                if (styleNode) {
                    const lnRefNode = styleNode.getElementsByTagNameNS(DML_NS, 'lnRef')[0];
                    if (lnRefNode) {
                        properties.rawStrokeNode = lnRefNode.outerHTML;
                        const idx = parseInt(lnRefNode.getAttribute('idx'));
                        if (idx > 0 && slideContext.theme.formatScheme.lines[idx - 1]) {
                            const themeLine = slideContext.theme.formatScheme.lines[idx - 1];
                            if (themeLine.type === 'solid') {
                                const strokeProps = { ...themeLine };
                                const lnRefColorObj = parseColor(lnRefNode);
                                if (lnRefColorObj) {
                                    strokeProps.color = resolveColor(lnRefColorObj, slideContext);
                                } else {
                                    strokeProps.color = resolveColor(themeLine.color, slideContext);
                                }
                                properties.stroke = strokeProps;
                            }
                        }
                    }
                }
            }

            // --- Default Fill Logic ---
            if (properties.fill === null && shapeNode.localName !== 'cxnSp') {
                 if (!properties.rawFillNode) { // Only apply default if no fill was specified at all
                    if (slideContext.theme && slideContext.theme.formatScheme.fills.length > 0) {
                        const defaultFill = slideContext.theme.formatScheme.fills[1] || slideContext.theme.formatScheme.fills[0]; // Often the second fill is the default shape fill
                        if (defaultFill.type === 'solid' && defaultFill.color) {
                            properties.fill = { type: 'solid', color: resolveColor(defaultFill.color, slideContext) };
                        }
                    }
                 }
            }
            return properties;
        }

        function parseTextStyle(styleNode) {
            if (!styleNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const styles = {};
            for (let i = 1; i <= 9; i++) {
                const lvlPr = styleNode.getElementsByTagNameNS(DML_NS, `lvl${i}pPr`)[0];
                if (lvlPr) {
                    styles[i - 1] = parseParagraphProperties(lvlPr);
                }
            }
            return styles;
        }

        function parseBodyProperties(txBodyNode) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const bodyPrNode = txBodyNode ? txBodyNode.getElementsByTagNameNS(DML_NS, 'bodyPr')[0] : null;

            if (!bodyPrNode) return {};

            const props = {};
            const anchor = bodyPrNode.getAttribute('anchor');
            if (anchor) props.anchor = anchor;

            const lIns = bodyPrNode.getAttribute('lIns');
            if (lIns) props.lIns = parseInt(lIns) / EMU_PER_PIXEL;

            const tIns = bodyPrNode.getAttribute('tIns');
            if (tIns) props.tIns = parseInt(tIns) / EMU_PER_PIXEL;

            const rIns = bodyPrNode.getAttribute('rIns');
            if (rIns) props.rIns = parseInt(rIns) / EMU_PER_PIXEL;

            const bIns = bodyPrNode.getAttribute('bIns');
            if (bIns) props.bIns = parseInt(bIns) / EMU_PER_PIXEL;

            return props;
        }

        function parseParagraphProperties(pPrNode) {
            if (!pPrNode) return {};

            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const properties = { bullet: {}, defRPr: {} };

            const align = pPrNode.getAttribute('algn');
            if (align) properties.align = align;

            const marL = pPrNode.getAttribute('marL');
            if (marL) properties.indent = parseInt(marL) / EMU_PER_PIXEL;

            const buNone = pPrNode.getElementsByTagNameNS(DML_NS, 'buNone')[0];
            if (buNone) properties.bullet.type = 'none';

            const buChar = pPrNode.getElementsByTagNameNS(DML_NS, 'buChar')[0];
            if (buChar) {
                properties.bullet.type = 'char';
                properties.bullet.char = buChar.getAttribute('char');
            }

            const buFont = pPrNode.getElementsByTagNameNS(DML_NS, 'buFont')[0];
            if (buFont) {
                properties.bullet.font = buFont.getAttribute('typeface');
            }

            const buAutoNum = pPrNode.getElementsByTagNameNS(DML_NS, 'buAutoNum')[0];
            if (buAutoNum) {
                properties.bullet.type = 'auto';
                properties.bullet.scheme = buAutoNum.getAttribute('type');
                properties.bullet.startAt = parseInt(buAutoNum.getAttribute('startAt') || '1');
            }

            const buBlip = pPrNode.getElementsByTagNameNS(DML_NS, 'buBlip')[0];
            if (buBlip) {
                const blip = buBlip.getElementsByTagNameNS(DML_NS, 'blip')[0];
                if (blip) {
                    properties.bullet.type = 'image';
                    properties.bullet.relId = blip.getAttribute('r:embed');
                }
            }

            const buSzPct = pPrNode.getElementsByTagNameNS(DML_NS, 'buSzPct')[0];
            if (buSzPct) {
                properties.bullet.size = `${parseInt(buSzPct.getAttribute('val')) / 1000}%`;
            }

            const buSzPts = pPrNode.getElementsByTagNameNS(DML_NS, 'buSzPts')[0];
            if (buSzPts) {
                properties.bullet.size = `${parseInt(buSzPts.getAttribute('val')) / 100}pt`;
            }

            const buClr = pPrNode.getElementsByTagNameNS(DML_NS, 'buClr')[0];
            if (buClr) {
                // Here, the color element is not a solidFill, but a direct child
                const srgbClr = buClr.getElementsByTagNameNS(DML_NS, 'srgbClr')[0];
                if (srgbClr) {
                    properties.bullet.color = { srgb: `#${srgbClr.getAttribute('val')}` };
                }
                const schemeClr = buClr.getElementsByTagNameNS(DML_NS, 'schemeClr')[0];
                if (schemeClr) {
                    properties.bullet.color = parseColor(buClr);
                }
            }

            const defRPrNode = pPrNode.getElementsByTagNameNS(DML_NS, 'defRPr')[0];
            if (defRPrNode) {
                const sz = defRPrNode.getAttribute('sz');
                if (sz) {
                    properties.defRPr.size = (parseInt(sz) / 100) * PT_TO_PX;
                }
                properties.defRPr.bold = defRPrNode.getAttribute('b') === '1';
                properties.defRPr.italic = defRPrNode.getAttribute('i') === '1';

                const solidFillNode = defRPrNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];
                if (solidFillNode) {
                    properties.defRPr.color = parseColor(solidFillNode);
                }

                const latinFontNode = defRPrNode.getElementsByTagNameNS( DML_NS, 'latin' )[ 0 ];
                if ( latinFontNode && latinFontNode.getAttribute( 'typeface' ) ) {
                    properties.defRPr.font = latinFontNode.getAttribute( 'typeface' );
                }
            }

            return properties;
        }

        function parseMasterOrLayout(xml, theme, masterColorMap = null, isLayout = false) {
            const xmlDoc = parseXmlString(xml, isLayout ? "slideLayout" : "slideMaster");
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const placeholders = {};
            const staticShapes = [];
            const defaultTextStyles = {};
            let colorMap = null;
            let colorMapOverride = null;

            if (isLayout) {
                const clrMapOvrNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'clrMapOvr')[0];
                if (clrMapOvrNode) {
                    const overrideNode = clrMapOvrNode.getElementsByTagNameNS(DML_NS, 'overrideClrMapping')[0];
                    if (overrideNode) {
                        colorMapOverride = parseColorMap(overrideNode);
                    }
                }
            } else {
                const clrMapNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'clrMap')[0];
                colorMap = parseColorMap(clrMapNode);
            }

            const txStyles = xmlDoc.getElementsByTagNameNS(PML_NS, 'txStyles')[0];
            if (txStyles) {
                defaultTextStyles.title = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'titleStyle')[0]);
                defaultTextStyles.body = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'bodyStyle')[0]);
                defaultTextStyles.other = parseTextStyle(txStyles.getElementsByTagNameNS(PML_NS, 'otherStyle')[0]);
            }

            const spTreeNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'spTree')[0];
            if (spTreeNode) {
                for (const shapeNode of spTreeNode.children) {
                    const supportedNodes = ['sp', 'cxnSp', 'grpSp', 'graphicFrame', 'pic'];
                    if (!supportedNodes.includes(shapeNode.localName)) {
                        continue;
                    }

                    const nvPr = shapeNode.getElementsByTagNameNS(PML_NS, 'nvPr')[0];
                    const ph = nvPr ? nvPr.getElementsByTagNameNS(PML_NS, 'ph')[0] : null;

                    if (ph) {
                        const type = ph.getAttribute('type');
                        const idx = ph.getAttribute('idx');
                        const key = idx ? `idx_${idx}` : type;

                        const xfrmNode = shapeNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
                        if (xfrmNode) {
                            const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                            const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                            if (offNode && extNode) {
                                const pos = {
                                    x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                                    y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                                    width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                                    height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                                };
                                let listStyle = null;
                                let bodyPr = {};
                                const txBodyNode = shapeNode.getElementsByTagNameNS(PML_NS, 'txBody')[0];
                                if (txBodyNode) {
                                    const lstStyleNode = txBodyNode.getElementsByTagNameNS(DML_NS, 'lstStyle')[0];
                                    if (lstStyleNode) {
                                        listStyle = parseTextStyle(lstStyleNode);
                                    }
                                    bodyPr = parseBodyProperties(txBodyNode);
                                }

                                const tempSlideContext = {
                                    theme: theme,
                                    colorMap: isLayout ? { ...(masterColorMap || {}), ...(colorMapOverride || {}) } : colorMap,
                                };
                                const shapeProps = parseShapeProperties(shapeNode, tempSlideContext, "layout/master");

                                placeholders[key] = { pos, type, listStyle, shapeProps, bodyPr };
                            }
                        }
                        if (type === 'pic') {
                            staticShapes.push(shapeNode);
                        }
                    } else {
                        staticShapes.push(shapeNode);
                    }
                }
            }
            return { placeholders, staticShapes, defaultTextStyles, colorMap, colorMapOverride };
        }

        function calculateTextBlockSize(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr) {
            const layout = layoutParagraphs(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr);
            return { height: layout.totalHeight };
        }

        async function processParagraphs(textGroup, txBody, pos, phKey, phType, slideContext, imageMap, listCounters, defaultTextStyles, masterPlaceholders, layoutPlaceholders, bodyPr = {}) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const paragraphs = Array.from(txBody.getElementsByTagNameNS(DML_NS, 'p'));
            if (paragraphs.length === 0) return;

            const layout = layoutParagraphs(paragraphs, pos, defaultTextStyles, phKey, phType, masterPlaceholders, layoutPlaceholders, slideContext, bodyPr);

            const paddedPos = {
                x: pos.x + (bodyPr.lIns || 0),
                y: pos.y + (bodyPr.tIns || 0),
                width: pos.width - (bodyPr.lIns || 0) - (bodyPr.rIns || 0),
                height: pos.height - (bodyPr.tIns || 0) - (bodyPr.bIns || 0),
            };

            let startY = paddedPos.y;
            const anchor = bodyPr.anchor || 't';
            if (anchor === 'ctr') {
                startY += (paddedPos.height - layout.totalHeight) / 2;
            } else if (anchor === 'b') {
                startY += paddedPos.height - layout.totalHeight;
            }

            for (const line of layout.lines) {
                const finalProps = line.paragraphProps;
                const bulletOffset = (finalProps.bullet.type && finalProps.bullet.type !== 'none') ? BULLET_OFFSET : 0;

                if (bulletOffset > 0 && line.isFirstLineOfParagraph) {
                    let bulletEl;
                    const bulletColor = resolveColor(finalProps.bullet.color, slideContext) || resolveColor(finalProps.defRPr.color, slideContext);
                    const bulletFontSize = finalProps.defRPr.size || 18;
                    const bulletY = startY + line.startY;

                    if (finalProps.bullet.type === 'char') {
                        bulletEl = new Konva.Text({ x: line.x - bulletOffset, y: bulletY, text: finalProps.bullet.char, fontSize: bulletFontSize, fontFamily: finalProps.bullet.font || 'Arial', fill: bulletColor });
                    } else if (finalProps.bullet.type === 'auto') {
                        const level = finalProps.level || 0;
                        if (!listCounters[level]) listCounters[level] = finalProps.bullet.startAt || 1;
                        const bulletChar = getAutoNumberingChar(finalProps.bullet.scheme, listCounters[level]++);
                        bulletEl = new Konva.Text({ x: line.x - bulletOffset, y: bulletY, text: bulletChar, fontSize: bulletFontSize, fontFamily: finalProps.bullet.font || 'Arial', fill: bulletColor });
                    } else if (finalProps.bullet.type === 'image' && finalProps.bullet.relId && imageMap[finalProps.bullet.relId]) {
                        const imageObj = await createImage(imageMap[finalProps.bullet.relId]);
                        bulletEl = new Konva.Image({ x: line.x - bulletOffset, y: bulletY, image: imageObj, width: 16, height: 16 });
                    }

                    if (bulletEl) textGroup.add(bulletEl);
                }

                let currentX = line.x;
                for (const textRun of line.runs) {
                    textRun.x(currentX);
                    textRun.y(startY + line.startY); // Use the calculated startY for the line
                    textGroup.add(textRun);
                    currentX += textRun.width();
                }
            }
        }

        async function processShape(shape, layer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum) {
            const nvPr = shape.getElementsByTagNameNS("http://schemas.openxmlformats.org/presentationml/2006/main", 'nvPr')[0];
            const shapeName = nvPr?.getElementsByTagNameNS("http://schemas.openxmlformats.org/presentationml/2006/main", 'cNvPr')[0]?.getAttribute('name');
            console.group(`JULES_LOG: Processing Shape: ${shapeName || shape.localName}`);
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const shapeName = nvPr?.getElementsByTagNameNS(PML_NS, 'cNvPr')[0]?.getAttribute('name');
            console.group(`JULES_LOG: Processing Shape: ${shapeName || shape.localName}`);
            let phKey = null, phType = null;
            if (nvPr) {
                const placeholder = nvPr.getElementsByTagNameNS(PML_NS, 'ph')[0];
                if (placeholder) {
                    phType = placeholder.getAttribute('type');
                    const phIdx = placeholder.getAttribute('idx');
                    phKey = phIdx ? `idx_${phIdx}` : phType;
                    if (!phType && phIdx) phType = 'body';
                }
            }

            const xfrmNode = shape.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
            let transform = { x: 0, y: 0, rot: 0, flipH: false, flipV: false };
            let geometry = { w: 0, h: 0 };
            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    transform.x = parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL;
                    transform.y = parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL;
                    geometry.w = parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL;
                    geometry.h = parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL;
                    transform.rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                    transform.flipH = xfrmNode.getAttribute('flipH') === '1';
                    transform.flipV = xfrmNode.getAttribute('flipV') === '1';
                }
            } else if (phKey && (layoutPlaceholders?.[phKey] || masterPlaceholders?.[phKey])) {
                const placeholder = layoutPlaceholders?.[phKey] || masterPlaceholders?.[phKey];
                if (placeholder) {
                    transform.x = placeholder.pos.x;
                    transform.y = placeholder.pos.y;
                    geometry.w = placeholder.pos.width;
                    geometry.h = placeholder.pos.height;
                }
            }

            const localMatrix = getTransformationMatrix(transform, geometry);
            const finalMatrix = Matrix.multiply(parentMatrix, localMatrix);
            const decomposed = decompose(finalMatrix);

            // Calculate the final position of the shape's center.
            const centerPoint = Matrix.transformPoint({ x: geometry.w / 2, y: geometry.h / 2 }, finalMatrix);

            console.log('Parent Matrix:', JSON.stringify(parentMatrix, null, 2));
            console.log('Local Transform:', transform);
            console.log('Final Matrix:', JSON.stringify(finalMatrix, null, 2));
            console.log('Center Point:', centerPoint);
            console.log('Decomposed:', decomposed);

            const konvaConfig = {
                x: centerPoint.x,
                y: centerPoint.y,
                width: geometry.w,
                height: geometry.h,
                rotation: decomposed.rotation,
                scaleX: decomposed.scaleX,
                scaleY: decomposed.scaleY,
                offsetX: geometry.w / 2,
                offsetY: geometry.h / 2,
            };

            const masterPh = masterPlaceholders ? masterPlaceholders[phKey] : null;
            const masterShapeProps = masterPh ? masterPh.shapeProps : {};
            const layoutPh = layoutPlaceholders ? layoutPlaceholders[phKey] : null;
            const layoutShapeProps = layoutPh ? layoutPh.shapeProps : {};
            const slideShapeProps = parseShapeProperties(shape, slideContext, slideNum);
            const finalFill = slideShapeProps.fill ?? layoutShapeProps.fill ?? masterShapeProps.fill;
            const finalStroke = slideShapeProps.stroke ?? layoutShapeProps.stroke ?? masterShapeProps.stroke;
            const shapeProps = {
                geometry: slideShapeProps.geometry ?? layoutShapeProps.geometry ?? masterShapeProps.geometry,
                fill: finalFill,
                stroke: finalStroke,
            };

            let konvaShape;
            if (shapeProps && shapeProps.geometry) {
                const geomType = shapeProps.geometry.type === 'preset' ? shapeProps.geometry.preset : shapeProps.geometry.type;
                switch (geomType) {
                    case 'rect': konvaShape = new Konva.Rect(konvaConfig); break;
                    case 'ellipse': konvaShape = new Konva.Ellipse({ ...konvaConfig, radiusX: geometry.w / 2, radiusY: geometry.h / 2 }); break;
                    case 'line': konvaShape = new Konva.Line({ ...konvaConfig, points: [-geometry.w / 2, 0, geometry.w / 2, 0] }); break; // A line's bounding box is tricky
                    default: konvaShape = new Konva.Rect(konvaConfig);
                }

                if (konvaShape) {
                    if (shapeProps.fill?.type === 'solid') konvaShape.fill(shapeProps.fill.color); else konvaShape.fillEnabled(false);
                    if (shapeProps.stroke) {
                        konvaShape.stroke(shapeProps.stroke.color);
                        konvaShape.strokeWidth(shapeProps.stroke.width || 1);
                        konvaShape.strokeScaleEnabled(false);
                    } else {
                        konvaShape.strokeEnabled(false);
                    }
                    layer.add(konvaShape);
                }
            }

            const txBody = shape.getElementsByTagNameNS(PML_NS, 'txBody')[0];
            if (txBody) {
                const textGroup = new Konva.Group(konvaConfig);
                layer.add(textGroup);
                const slideBodyPr = parseBodyProperties(txBody);
                const masterBodyPr = masterPh ? masterPh.bodyPr : {};
                const layoutBodyPr = layoutPh ? layoutPh.bodyPr : {};
                const finalBodyPr = { ...masterBodyPr, ...layoutBodyPr, ...slideBodyPr };
                const textPos = { x: 0, y: 0, width: geometry.w, height: geometry.h };
                await processParagraphs(textGroup, txBody, textPos, phKey, phType, slideContext, imageMap, listCounters, defaultTextStyles, masterPlaceholders, layoutPlaceholders, finalBodyPr);
            }
            console.groupEnd();
        }

        function parseGroupShapeProperties(grpSpPrNode, slideContext) {
            if (!grpSpPrNode) return null;
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const properties = { fill: null, ext: null };

            const xfrmNode = grpSpPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0];
            if (xfrmNode) {
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'chExt')[0];
                if (extNode) {
                    properties.ext = {
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                    };
                }
            }

            let solidFillNode = null;
            let noFillNode = null;
            for (const child of grpSpPrNode.children) {
                if (child.localName === 'solidFill') {
                    solidFillNode = child;
                    break;
                }
                if (child.localName === 'noFill') {
                    noFillNode = child;
                    break;
                }
            }

            if (noFillNode) {
                properties.fill = 'none';
            } else if (solidFillNode) {
                const colorObj = parseColor(solidFillNode);
                if (colorObj) {
                    properties.fill = { type: 'solid', color: resolveColor(colorObj, slideContext) };
                }
            }
            return properties;
        }

        async function processGroupShape(group, layer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum, slideRels, entriesMap) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const nvPr = group.getElementsByTagNameNS(PML_NS, 'nvSpPr')[0];
            const groupName = nvPr?.getElementsByTagNameNS(PML_NS, 'cNvPr')[0]?.getAttribute('name');
            console.group(`JULES_LOG: Processing Group: ${groupName || 'Unnamed Group'}`);
            console.log('Incoming Parent Matrix:', JSON.stringify(parentMatrix, null, 2));

            const grpSpPrNode = group.getElementsByTagNameNS(PML_NS, 'grpSpPr')[0];
            const xfrmNode = grpSpPrNode ? grpSpPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0] : null;

            let transform = { x: 0, y: 0, rot: 0, flipH: false, flipV: false };
            let geometry = { w: 0, h: 0 };
            let childTransform = { x: 0, y: 0 };

            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                if (offNode) {
                    transform.x = parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL;
                    transform.y = parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL;
                }

                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (extNode) {
                    geometry.w = parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL;
                    geometry.h = parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL;
                }

                const chOffNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'chOff')[0];
                if (chOffNode) {
                    childTransform.x = parseInt(chOffNode.getAttribute("x")) / EMU_PER_PIXEL;
                    childTransform.y = parseInt(chOffNode.getAttribute("y")) / EMU_PER_PIXEL;
                }

                transform.rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                transform.flipH = xfrmNode.getAttribute('flipH') === '1';
                transform.flipV = xfrmNode.getAttribute('flipV') === '1';
            }

            // Create a new Konva group for this XML group.
            // Unlike the old logic, we don't apply transforms directly.
            // The transforms will be passed down to children.
            const konvaGroup = new Konva.Group();
            layer.add(konvaGroup);

            // The group's own transform is combined with the parent's for the children.
            const localMatrix = getTransformationMatrix(transform, geometry);

            // The 'chOff' (child offset) is a special property of groups. It effectively creates a new coordinate system
            // for the children. We can represent this as a translation matrix.
            const childOffsetMatrix = Matrix.translate(childTransform.x, childTransform.y);

            // The final matrix for the children is Parent * Group's Transform * Child Offset
            const finalMatrixForChildren = Matrix.multiply(Matrix.multiply(parentMatrix, localMatrix), childOffsetMatrix);

            // Process children, passing the new combined matrix.
            const spTreeNode = group.getElementsByTagNameNS(PML_NS, 'spTree')[0];
            if (spTreeNode) {
                 await processShapeTree(spTreeNode.children, konvaGroup, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, slideRels, entriesMap, finalMatrixForChildren);
            }

            console.log('Group Local Matrix:', JSON.stringify(localMatrix, null, 2));
            console.log('Final Matrix for Children:', JSON.stringify(finalMatrixForChildren, null, 2));
            console.groupEnd();
        }

        function getCellBorders(cellNode, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const borders = {};
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];

            if (tcPrNode) {
                const borderMap = { 'lnL': 'left', 'lnR': 'right', 'lnT': 'top', 'lnB': 'bottom' };
                for (const child of tcPrNode.children) {
                    const side = borderMap[child.localName];
                    if (side) {
                        const lnNode = child;
                        const noFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'noFill')[0];
                        const solidFillNode = lnNode.getElementsByTagNameNS(DML_NS, 'solidFill')[0];

                        if (noFillNode) {
                            borders[side] = 'none';
                        } else if (solidFillNode) {
                            const colorObj = parseColor(solidFillNode);
                            const width = parseInt(lnNode.getAttribute('w') || '0') / EMU_PER_PIXEL;
                            if (colorObj && width > 0) {
                                borders[side] = {
                                    color: resolveColor(colorObj, slideContext),
                                    width: width
                                };
                            }
                        }
                    }
                }
            }
            // TODO: Fallback to table style for borders
            return borders;
        }

        function getCellFillColor(cellNode, tblPrNode, r, c, numRows, numCols, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            // Level 1: Direct Formatting
            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];
            if (tcPrNode) {
                // Find the solidFill that is a direct child of tcPr, not nested in lnL, etc.
                let solidFillNode = null;
                for (const child of tcPrNode.children) {
                    if (child.localName === 'solidFill') {
                        solidFillNode = child;
                        break;
                    }
                }

                if (solidFillNode) {
                    const colorObj = parseColor(solidFillNode);
                    if (colorObj) {
                        return resolveColor(colorObj, slideContext);
                    }
                }
            }

            // Levels 2 & 3: Table Styles
            const tableStyleIdNode = tblPrNode ? tblPrNode.getElementsByTagNameNS(DML_NS, 'tableStyleId')[0] : null;
            if (!tableStyleIdNode) {
                return null;
            }

            const styleId = tableStyleIdNode.textContent;
            const tableStyle = slideContext.tableStyles[styleId];
            if (!tableStyle) {
                return null;
            }

            const firstRow = tblPrNode.getAttribute('firstRow') === '1';
            const lastRow = tblPrNode.getAttribute('lastRow') === '1';
            const firstCol = tblPrNode.getAttribute('firstCol') === '1';
            const lastCol = tblPrNode.getAttribute('lastCol') === '1';
            const bandRow = tblPrNode.getAttribute('bandRow') === '1';
            const bandCol = tblPrNode.getAttribute('bandCol') === '1';

            const isFirstRow = r === 0;
            const isLastRow = r === numRows - 1;
            const isFirstCol = c === 0;
            const isLastCol = c === numCols - 1;

            let stylePart = null;

            if (firstRow && isFirstRow && firstCol && isFirstCol && tableStyle.nwCell) { stylePart = tableStyle.nwCell; }
            else if (firstRow && isFirstRow && lastCol && isLastCol && tableStyle.neCell) { stylePart = tableStyle.neCell; }
            else if (lastRow && isLastRow && firstCol && isFirstCol && tableStyle.swCell) { stylePart = tableStyle.swCell; }
            else if (lastRow && isLastRow && lastCol && isLastCol && tableStyle.seCell) { stylePart = tableStyle.seCell; }
            else if (firstRow && isFirstRow && tableStyle.firstRow) { stylePart = tableStyle.firstRow; }
            else if (lastRow && isLastRow && tableStyle.lastRow) { stylePart = tableStyle.lastRow; }
            else if (firstCol && isFirstCol && tableStyle.firstCol) { stylePart = tableStyle.firstCol; }
            else if (lastCol && isLastCol && tableStyle.lastCol) { stylePart = tableStyle.lastCol; }
            else if (bandRow) {
                const isDataRow = !(firstRow && isFirstRow);
                if (isDataRow) {
                    if (r % 2 === 1 && tableStyle.band1H) { stylePart = tableStyle.band1H; }
                    else if (r % 2 === 0 && tableStyle.band2H) { stylePart = tableStyle.band2H; }
                }
            }

            if (!stylePart && bandCol) {
                const isDataCol = !(firstCol && isFirstCol) && !(lastCol && isLastCol);
                if (isDataCol) {
                    if (c % 2 === 1 && tableStyle.band1V) { stylePart = tableStyle.band1V; }
                    else if (c % 2 === 0 && tableStyle.band2V) { stylePart = tableStyle.band2V; }
                }
            }

            if (stylePart && stylePart.tcStyle && stylePart.tcStyle.fill) {
                return resolveColor(stylePart.tcStyle.fill, slideContext);
            }

            const wholeTblStyle = tableStyle.wholeTbl;
            if (wholeTblStyle && wholeTblStyle.tcStyle && wholeTblStyle.tcStyle.fill) {
                return resolveColor(wholeTblStyle.tcStyle.fill, slideContext);
            }

            return null;
        }

        async function processTable(graphicFrame, layer, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";

            // 1. Get position and size of the graphic frame
            const xfrmNode = graphicFrame.getElementsByTagNameNS(PML_NS, 'xfrm')[0];
            let pos = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    pos = {
                        x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                        y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                        width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                        height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
                    };
                }
            }

            const tblNode = graphicFrame.getElementsByTagNameNS(DML_NS, 'tbl')[0];
            if (!tblNode) return {
                width: pos.width,
                height: pos.height
            };

            const tblPrNode = tblNode.getElementsByTagNameNS(DML_NS, 'tblPr')[0];

            const tableStyleIdNode = tblPrNode ? tblPrNode.getElementsByTagNameNS(DML_NS, 'tableStyleId')[0] : null;
            const styleId = tableStyleIdNode ? tableStyleIdNode.textContent : null;

            // 2. Parse grid and column widths
            const tblGridNode = tblNode.getElementsByTagNameNS(DML_NS, 'tblGrid')[0];
            const gridColNodes = tblGridNode ? tblGridNode.getElementsByTagNameNS(DML_NS, 'gridCol') : [];
            const colWidths = Array.from(gridColNodes).map(node => parseInt(node.getAttribute('w')) / EMU_PER_PIXEL);

            // 3. Iterate through rows and cells to build a renderable grid
            const rowNodes = Array.from(tblNode.getElementsByTagNameNS(DML_NS, 'tr'));
            const numRows = rowNodes.length;
            const numCols = colWidths.length;
            if (numRows === 0 || numCols === 0) return {
                width: pos.width,
                height: pos.height
            };

            const renderedGrid = Array(numRows).fill(0).map(() => Array(numCols).fill(false));

            for (let r = 0; r < numRows; r++) {
                const cellNodes = Array.from(rowNodes[r].getElementsByTagNameNS(DML_NS, 'tc'));

                for (let c = 0; c < numCols; c++) {
                    if (renderedGrid[r][c]) {
                        continue; // Already handled by a previous rowspan
                    }

                    const cellNode = cellNodes[c];
                    if (!cellNode) continue;

                    const hMerge = cellNode.getAttribute('hMerge') === '1';
                    const vMerge = cellNode.getAttribute('vMerge') === '1';

                    if (hMerge || vMerge) {
                        continue; // Handled by the primary cell of the merge
                    }

                    const gridSpan = parseInt(cellNode.getAttribute('gridSpan') || '1');
                    const rowSpan = parseInt(cellNode.getAttribute('rowSpan') || '1');

                    // Calculate cell dimensions based on spans
                    let cellWidth = 0;
                    for (let i = 0; i < gridSpan; i++) {
                        if (c + i < numCols) cellWidth += colWidths[c + i];
                    }

                    let cellHeight = 0;
                    for (let i = 0; i < rowSpan; i++) {
                        if (r + i < numRows) {
                            cellHeight += parseInt(rowNodes[r + i].getAttribute('h')) / EMU_PER_PIXEL;
                        }
                    }

                    // Calculate cell position
                    let cellX = pos.x;
                    for (let i = 0; i < c; i++) {
                        cellX += colWidths[i];
                    }

                    let cellY = pos.y;
                    for (let i = 0; i < r; i++) {
                        cellY += parseInt(rowNodes[i].getAttribute('h')) / EMU_PER_PIXEL;
                    }

                    // Mark grid cells covered by this span as rendered
                    for (let i = 0; i < rowSpan; i++) {
                        for (let j = 0; j < gridSpan; j++) {
                            if (r + i < numRows && c + j < numCols) {
                                renderedGrid[r + i][c + j] = true;
                            }
                        }
                    }

                    // Step 4: Get cell styling
                    const fillColor = getCellFillColor(cellNode, tblPrNode, r, c, numRows, numCols, slideContext);

                    const cellRect = new Konva.Rect({
                        x: cellX,
                        y: cellY,
                        width: cellWidth,
                        height: cellHeight,
                        fill: fillColor || 'transparent',
                    });
                    layer.add(cellRect);

                    // Draw borders using a strategy to avoid double-drawing
                    const borders = getCellBorders(cellNode, slideContext);
                    const borderDefs = {
                        top: { p: [cellX, cellY, cellX + cellWidth, cellY], draw: (r === 0) },
                        right: { p: [cellX + cellWidth, cellY, cellX + cellWidth, cellY + cellHeight], draw: true },
                        bottom: { p: [cellX + cellWidth, cellY + cellHeight, cellX, cellY + cellHeight], draw: true },
                        left: { p: [cellX, cellY + cellHeight, cellX, cellY], draw: (c === 0) },
                    };

                    for (const side in borderDefs) {
                        const borderStyle = borders[side];
                        if (borderStyle && borderStyle !== 'none' && borderDefs[side].draw) {
                            const border = new Konva.Line({
                                points: borderDefs[side].p,
                                stroke: borderStyle.color,
                                strokeWidth: borderStyle.width,
                                listening: false, // Make lines non-interactive
                            });
                            layer.add(border);
                        }
                    }

                    // Render text content
                    await processCellText(cellNode, layer, cellX, cellY, cellWidth, cellHeight, slideContext);
                }
            }

            return {
                width: pos.width,
                height: pos.height
            };
        }

        async function processCellText(cellNode, layer, cellX, cellY, cellWidth, cellHeight, slideContext) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const txBodyNode = cellNode.getElementsByTagNameNS(DML_NS, 'txBody')[0];
            if (!txBodyNode) return;

            const tcPrNode = cellNode.getElementsByTagNameNS(DML_NS, 'tcPr')[0];
            const bodyPrFromTxBody = parseBodyProperties(txBodyNode);

            const bodyPrFromTcPr = {};
            if (tcPrNode) {
                const anchor = tcPrNode.getAttribute('anchor');
                if (anchor) bodyPrFromTcPr.anchor = anchor;

                const marL = tcPrNode.getAttribute('marL');
                if (marL) bodyPrFromTcPr.lIns = parseInt(marL) / EMU_PER_PIXEL;

                const marT = tcPrNode.getAttribute('marT');
                if (marT) bodyPrFromTcPr.tIns = parseInt(marT) / EMU_PER_PIXEL;

                const marR = tcPrNode.getAttribute('marR');
                if (marR) bodyPrFromTcPr.rIns = parseInt(marR) / EMU_PER_PIXEL;

                const marB = tcPrNode.getAttribute('marB');
                if (marB) bodyPrFromTcPr.bIns = parseInt(marB) / EMU_PER_PIXEL;
            }

            const bodyPr = { ...bodyPrFromTxBody, ...bodyPrFromTcPr };

            const pos = {
                x: cellX,
                y: cellY,
                width: cellWidth,
                height: cellHeight
            };

            const textGroup = new Konva.Group({
                x: 0,
                y: 0,
                width: cellWidth,
                height: cellHeight,
                clipFunc: (ctx) => {
                    ctx.rect(cellX, cellY, cellWidth, cellHeight);
                }
            });
            layer.add(textGroup);

            const listCounters = {};
            const defaultTextStyles = { title: {}, body: {}, other: {} };
            const masterPlaceholders = {};
            const layoutPlaceholders = {};

            await processParagraphs(textGroup, txBodyNode, pos, null, 'body', slideContext, {}, listCounters, defaultTextStyles, masterPlaceholders, layoutPlaceholders, bodyPr);
        }

        async function processPicture(picNode, layer, imageMap, parentMatrix, masterPlaceholders, layoutPlaceholders, slideContext) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const nvPicPrNode = picNode.getElementsByTagNameNS(PML_NS, 'nvPicPr')[0];
            const nvPrNode = nvPicPrNode ? nvPicPrNode.getElementsByTagNameNS(PML_NS, 'nvPr')[0] : null;
            const phNode = nvPrNode ? nvPrNode.getElementsByTagNameNS(PML_NS, 'ph')[0] : null;

            const spPrNode = picNode.getElementsByTagNameNS(PML_NS, 'spPr')[0];
            const xfrmNode = spPrNode ? spPrNode.getElementsByTagNameNS(DML_NS, 'xfrm')[0] : null;

            let transform = { x: 0, y: 0, rot: 0, flipH: false, flipV: false };
            let geometry = { w: 0, h: 0 };

            if (xfrmNode) {
                const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
                const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
                if (offNode && extNode) {
                    transform.x = parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL;
                    transform.y = parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL;
                    geometry.w = parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL;
                    geometry.h = parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL;
                    transform.rot = parseInt(xfrmNode.getAttribute('rot') || '0') / 60000;
                    transform.flipH = xfrmNode.getAttribute('flipH') === '1';
                    transform.flipV = xfrmNode.getAttribute('flipV') === '1';
                }
            } else if (phNode && (layoutPlaceholders || masterPlaceholders)) {
                const phKey = phNode.getAttribute('idx') ? `idx_${phNode.getAttribute('idx')}` : phNode.getAttribute('type');
                const placeholder = layoutPlaceholders?.[phKey] || masterPlaceholders?.[phKey];
                if (placeholder) {
                    transform.x = placeholder.pos.x;
                    transform.y = placeholder.pos.y;
                    geometry.w = placeholder.pos.width;
                    geometry.h = placeholder.pos.height;
                }
            }

            const localMatrix = getTransformationMatrix(transform, geometry);
            const finalMatrix = Matrix.multiply(parentMatrix, localMatrix);
            const decomposed = decompose(finalMatrix);
            const centerPoint = Matrix.transformPoint({ x: geometry.w / 2, y: geometry.h / 2 }, finalMatrix);

            const konvaConfig = {
                x: centerPoint.x,
                y: centerPoint.y,
                width: geometry.w,
                height: geometry.h,
                rotation: decomposed.rotation,
                scaleX: decomposed.scaleX,
                scaleY: decomposed.scaleY,
                offsetX: geometry.w / 2,
                offsetY: geometry.h / 2,
            };

            const blipFillNode = picNode.getElementsByTagNameNS(PML_NS, 'blipFill')[0];
            if (!blipFillNode) return;
            const blipNode = blipFillNode.getElementsByTagNameNS(DML_NS, 'blip')[0];
            if (!blipNode) return;
            const relId = blipNode.getAttribute('r:embed');
            if (!relId || !imageMap[relId]) return;

            try {
                const imageObj = await createImage(imageMap[relId]);
                const konvaImage = new Konva.Image({
                    ...konvaConfig,
                    image: imageObj,
                });
                layer.add(konvaImage);
            } catch (e) {
                console.error("Error creating image", e);
            }
        }

        async function processShapeTree(elements, layer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, slideRels, entriesMap) {
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
            const parentMatrix = Matrix.identity();

            for (const element of elements) {
                const tagName = element.localName;
                if (tagName === 'sp' || tagName === 'cxnSp') {
                    await processShape(element, layer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum);
                } else if (tagName === 'grpSp') {
                    await processGroupShape(element, layer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, parentMatrix, defaultTextStyles, slideNum);
                } else if (tagName === 'graphicFrame') {
                    const graphicData = element.getElementsByTagNameNS(DML_NS, 'graphicData')[0];
                    if (graphicData && graphicData.getAttribute('uri') === 'http://schemas.openxmlformats.org/drawingml/2006/table') {
                        await processTable(element, layer, slideContext);
                    } else if (graphicData && graphicData.getAttribute('uri') === 'http://schemas.openxmlformats.org/drawingml/2006/chart') {
                        const chartRelId = graphicData.getElementsByTagNameNS("http://schemas.openxmlformats.org/drawingml/2006/chart", "chart")[0].getAttribute("r:id");
                        if (chartRelId && slideRels && slideRels[chartRelId]) {
                            const chartPath = resolvePath('ppt/slides', slideRels[chartRelId].target);
                            const chartXml = await getNormalizedXmlString(entriesMap, chartPath);
                            if (chartXml) {
                                const chartData = parseChart(chartXml);
                                await renderChart(element, layer, chartData);
                            }
                        }
                    }
                } else if (tagName === 'pic') {
                    await processPicture(element, layer, imageMap, parentMatrix, masterPlaceholders, layoutPlaceholders, slideContext);
                }
            }
        }

        async function renderSlide( slideXml, slideContainer, masterPlaceholders, layoutPlaceholders, slideNum, slideSize, defaultTextStyles, imageMap, slideContext, finalBg, showMasterShapes, masterStaticShapes, layoutStaticShapes, slideRels, entriesMap ) {
            activeCharts = []; // Clear previously rendered charts
            const xmlDoc = parseXmlString(slideXml, `slide number ${slideNum}`);
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";

            const listCounters = {};
            const stage = new Konva.Stage({
                container: slideContainer,
                width: slideSize.width,
                height: slideSize.height,
            });

            const bgLayer = new Konva.Layer();
            stage.add(bgLayer);
            if (finalBg) {
                if (finalBg.type === 'color') {
                    const bgRect = new Konva.Rect({
                        x: 0,
                        y: 0,
                        width: slideSize.width,
                        height: slideSize.height,
                        fill: finalBg.value,
                    });
                    bgLayer.add(bgRect);
                } else if (finalBg.type === 'image' && finalBg.relId && imageMap[finalBg.relId]) {
                    const imageObj = await createImage(imageMap[finalBg.relId]);
                    const bgImage = new Konva.Image({
                        x: 0,
                        y: 0,
                        image: imageObj,
                        width: slideSize.width,
                        height: slideSize.height,
                    });
                    bgLayer.add(bgImage);
                }
            }

            const mainLayer = new Konva.Layer();
            stage.add(mainLayer);

            if (showMasterShapes) {
                if (masterStaticShapes) {
                    await processShapeTree(masterStaticShapes, mainLayer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, null, entriesMap);
                }
                 if (layoutStaticShapes) {
                    await processShapeTree(layoutStaticShapes, mainLayer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, null, entriesMap);
                }
            }

            const spTreeNode = xmlDoc.getElementsByTagNameNS(PML_NS, 'spTree')[0];
            if (spTreeNode) {
                await processShapeTree(spTreeNode.children, mainLayer, masterPlaceholders, layoutPlaceholders, slideContext, imageMap, listCounters, defaultTextStyles, slideNum, slideRels, entriesMap);
            }

            const resizeStage = () => {
                const containerWidth = slideContainer.offsetWidth;
                if (containerWidth > 0) {
                    const scale = containerWidth / slideSize.width;
                    stage.scale({ x: scale, y: scale });
                    stage.width(slideSize.width * scale);
                    stage.height(slideSize.height * scale);

                    for (const chart of activeCharts) {
                        chart.container.style.left = `${chart.pos.x * scale}px`;
                        chart.container.style.top = `${chart.pos.y * scale}px`;
                        chart.container.style.width = `${chart.pos.width * scale}px`;
                        chart.container.style.height = `${chart.pos.height * scale}px`;
                    }
                }
            };

            resizeStage();

            const observer = new ResizeObserver(resizeStage);
            observer.observe(slideContainer);
        }

        function parseChart(chartXml) {
            const xmlDoc = parseXmlString(chartXml, "chart");
            const C_NS = "http://schemas.openxmlformats.org/drawingml/2006/chart";

            const chartData = {
                type: null,
                title: null,
                labels: [],
                datasets: []
            };

            const titleNode = xmlDoc.getElementsByTagNameNS(C_NS, 'title')[0];
            if (titleNode) {
                chartData.title = titleNode.textContent.trim();
            }

            const plotAreaNode = xmlDoc.getElementsByTagNameNS(C_NS, 'plotArea')[0];
            if (!plotAreaNode) return null;

            const chartTypeMap = {
                'barChart': 'bar',
                'lineChart': 'line',
                'pieChart': 'pie',
                // TODO: Add other chart types
            };

            let chartTypeNode;
            for (const type in chartTypeMap) {
                chartTypeNode = plotAreaNode.getElementsByTagNameNS(C_NS, type)[0];
                if (chartTypeNode) {
                    chartData.type = chartTypeMap[type];
                    break;
                }
            }

            if (!chartTypeNode) return null;

            const serNodes = chartTypeNode.getElementsByTagNameNS(C_NS, 'ser');
            for (const serNode of serNodes) {
                const dataset = {
                    label: '',
                    data: []
                };

                const txValNode = serNode.getElementsByTagNameNS(C_NS, 'tx')[0]?.getElementsByTagNameNS(C_NS, 'v')[0];
                if (txValNode) {
                    dataset.label = txValNode.textContent.trim();
                }

                const catNode = serNode.getElementsByTagNameNS(C_NS, 'cat')[0];
                if (catNode) {
                    const strRefNode = catNode.getElementsByTagNameNS(C_NS, 'strRef')[0];
                    if (strRefNode) {
                        const ptNodes = strRefNode.getElementsByTagNameNS(C_NS, 'pt');
                        chartData.labels = Array.from(ptNodes).map(pt => pt.textContent.trim());
                    }
                }

                const valNode = serNode.getElementsByTagNameNS(C_NS, 'val')[0];
                if (valNode) {
                    const numRefNode = valNode.getElementsByTagNameNS(C_NS, 'numRef')[0];
                    if (numRefNode) {
                        const ptNodes = numRefNode.getElementsByTagNameNS(C_NS, 'pt');
                        dataset.data = Array.from(ptNodes).map(pt => parseFloat(pt.textContent.trim()));
                    }
                }

                chartData.datasets.push(dataset);
            }

            return chartData;
        }

        async function renderChart(graphicFrame, layer, chartData) {
            const PML_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
            const DML_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";

            const xfrmNode = graphicFrame.getElementsByTagNameNS(PML_NS, 'xfrm')[0];
            if (!xfrmNode) return;

            const offNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'off')[0];
            const extNode = xfrmNode.getElementsByTagNameNS(DML_NS, 'ext')[0];
            if (!offNode || !extNode) return;

            const pos = {
                x: parseInt(offNode.getAttribute("x")) / EMU_PER_PIXEL,
                y: parseInt(offNode.getAttribute("y")) / EMU_PER_PIXEL,
                width: parseInt(extNode.getAttribute("cx")) / EMU_PER_PIXEL,
                height: parseInt(extNode.getAttribute("cy")) / EMU_PER_PIXEL,
            };

            // Since Konva doesn't directly support embedding charts, we create an
            // HTML overlay for the chart canvas.
            const chartContainer = document.createElement('div');
            chartContainer.style.position = 'absolute';
            // Defer positioning to the resizeStage function to handle scaling

            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);

            // The slide container is the Konva stage's parent. We need to append
            // our chart overlay to the same parent to make it appear on top.
            layer.getStage().container().appendChild(chartContainer);

            activeCharts.push({
                container: chartContainer,
                pos: pos
            });

            const ctx = canvas.getContext('2d');
            new Chart(ctx, {
                type: chartData.type,
                data: {
                    labels: chartData.labels,
                    datasets: chartData.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: !!chartData.title,
                            text: chartData.title
                        }
                    }
                }
            });
        }
    </script>
</body>

</html>